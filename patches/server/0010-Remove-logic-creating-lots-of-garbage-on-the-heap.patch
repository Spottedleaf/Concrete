From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 27 Aug 2019 15:08:24 -0700
Subject: [PATCH] Remove logic creating lots of garbage on the heap

- PathfinderGoalSelector showed up at the top in memory profiling due
to streams

- ChunkMapDistance showed up at the top too due to bad iterator usage

- PlayerChunkMap#move and ChunkMap showed near the top when moving
around due to avoidable ChunkCoordIntPair allocations

- PathFinderNormal allocates a block position when checking the path
type of a block

- Either.Left/Right do not cache the optional returned for left()/right()
 (getChunk type calls all have to go through them...)

- ObjectAVLTreeSet does not override removeIf, so the default uses
an iterator. removeIf is invoked heavily in ChunkMapDistance (on every
tick). Replace with an impl that caches the iterator

- Some lighting stuff allocating AtomicInteger for passing a second
return value from a function. use a field since the JIT is not stack
allocating the variable

- Randomly ticking a block would allocate a BlockPosition, replace
with mutable pos

- Entity iteration for ticking would use a non-fast iterator, thus
creating lots of garbage entries.

- Replace how the chunk map and light data is updated
   Before the underlying maps were copy on write, however this obviously
   will not scale well at all for large player counts. The replacement is
   a system which will queue updates to a map locked by a seqlock.
   Intentionally, the constructors/fields were clobbered, breaking
   the ABI.

- Vec3d allocation by tracker for checking a simple delta

- Iterator usage in hot areas

- Entry iteration in LightEngineStorage
   Fast iterator might look like it could not be used since that's only p
   rovided via the Long2ObjectOpenHashMap interface, and the map was
   synchronized via Long2ObjectMaps.synchronize - however the
   synchronized map does not wrap the iterator, so we can freely
   use the fast iterator without causing synchronization
   issues. Also target next() vs nextLong(), although they really
   did not show up in the profiler at all.

- Iterator creation in ProtoChunk#setType
   Avoid using an array

diff --git a/src/main/java/com/destroystokyo/paper/PaperCommand.java b/src/main/java/com/destroystokyo/paper/PaperCommand.java
index dfe92780ad288dd12f961ccad3e9f6f12b24287e..c088cf51ffcec243cf284e049a2b458d12b180ca 100644
--- a/src/main/java/com/destroystokyo/paper/PaperCommand.java
+++ b/src/main/java/com/destroystokyo/paper/PaperCommand.java
@@ -215,7 +215,7 @@ public class PaperCommand extends Command {
             int ticking = 0;
             int entityTicking = 0;
 
-            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.updatingChunks.values()) {
+            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.chunkMap.getUpdatingValues()) { // Tuinity - replace chunk map
                 if (chunk.getFullChunkIfCached() == null) {
                     continue;
                 }
diff --git a/src/main/java/com/mojang/datafixers/util/Either.java b/src/main/java/com/mojang/datafixers/util/Either.java
index a90adac7bd7ebd423f480e9ae0f44cb9d521fa4f..2e7cbf8bf5d1a31208940cefa74b630a953e2785 100644
--- a/src/main/java/com/mojang/datafixers/util/Either.java
+++ b/src/main/java/com/mojang/datafixers/util/Either.java
@@ -23,6 +23,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Left<L, R> extends Either<L, R> {
         private final L value;
+        private Optional<L> cachedLeft; // Tuinity - reduce allocation of these for chunks...
 
         public Left(final L value) {
             this.value = value;
@@ -51,7 +52,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<L> left() {
-            return Optional.of(value);
+            return this.cachedLeft == null ? this.cachedLeft = Optional.of(value) : this.cachedLeft; // Tuinity - cache optional
         }
 
         @Override
@@ -84,6 +85,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Right<L, R> extends Either<L, R> {
         private final R value;
+        private Optional<R> cachedRight; // Tuinity - reduce allocation of these for chunks...
 
         public Right(final R value) {
             this.value = value;
@@ -117,7 +119,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<R> right() {
-            return Optional.of(value);
+            return this.cachedRight == null ? this.cachedRight = Optional.of(value) : this.cachedRight; // Tuinity - cache optional
         }
 
         @Override
diff --git a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
index e997651111257025a50a427e687a2c36bd086213..e3b209d04633fffcdbda5ef0f200b2a21f26d03d 100644
--- a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
+++ b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
@@ -117,6 +117,45 @@ public final class TuinityConfig {
         tickThreads = TuinityConfig.getInt("server-tick-threads", 1); // will be 4 in the future
     }*/
 
+    public static double maxChunkSendsPerPlayer; // per second
+
+    public static int[] maxChunkSendsPerPlayerChoice = new int[100];
+
+    private static void maxChunkLoadsPerPlayer() {
+        if (TuinityConfig.configVersion < 1) {
+            TuinityConfig.set("max-pending-chunk-tickets-per-player", null);
+        }
+        maxChunkSendsPerPlayer = TuinityConfig.getDouble("target-chunk-sends-per-player-per-second", 40.0);
+        if (maxChunkSendsPerPlayer <= -1.0) {
+            maxChunkSendsPerPlayer = Integer.MAX_VALUE;
+        } else if (maxChunkSendsPerPlayer <= 1.0) {
+            maxChunkSendsPerPlayer = 1.0;
+        } else if (maxChunkSendsPerPlayer > Integer.MAX_VALUE) {
+            maxChunkSendsPerPlayer = Integer.MAX_VALUE;
+        }
+
+        double rateTick = maxChunkSendsPerPlayer / 20.0;
+        double a = Math.floor(rateTick);
+        double b = Math.ceil(rateTick);
+
+        // we want to spread out a and b over the interval so it's smooth
+
+        int aInt = (int)a;
+        int bInt = (int)b;
+        double total = b;
+        maxChunkSendsPerPlayerChoice[0] = bInt;
+
+        for (int i = 1, len = maxChunkSendsPerPlayerChoice.length; i < len; ++i) {
+            if (total / (double)i >= rateTick) {
+                total += a;
+                maxChunkSendsPerPlayerChoice[i] = aInt;
+            } else {
+                total += b;
+                maxChunkSendsPerPlayerChoice[i] = bInt;
+            }
+        }
+    }
+
     public static final class WorldConfig {
 
         public final String worldName;
@@ -235,6 +274,11 @@ public final class TuinityConfig {
             final int threads = this.getInt("tick-threads", -1);
             this.threads = threads == -1 ? TuinityConfig.tickThreads : threads;
         }*/
+
+        public int noTickViewDistance;
+        private void noTickViewDistance() {
+            this.noTickViewDistance = this.getInt("no-tick-view-distance", -1);
+        }
     }
 
 }
diff --git a/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedAbstractDoubleList.java b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedAbstractDoubleList.java
new file mode 100644
index 0000000000000000000000000000000000000000..88b198fd7bccdaa294ab436ede0242c028f744c4
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedAbstractDoubleList.java
@@ -0,0 +1,39 @@
+package com.tuinity.tuinity.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.List;
+
+public abstract class ExtendedAbstractDoubleList extends AbstractDoubleList {
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedDoubleArrayList.java b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedDoubleArrayList.java
new file mode 100644
index 0000000000000000000000000000000000000000..36457981ee9599a8c291e77f60f387f4f00ba764
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedDoubleArrayList.java
@@ -0,0 +1,65 @@
+package com.tuinity.tuinity.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class ExtendedDoubleArrayList extends DoubleArrayList {
+
+    public ExtendedDoubleArrayList() {
+        super();
+    }
+
+    public ExtendedDoubleArrayList(final int capacity) {
+        super(capacity);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array) {
+        this(array, array.length, true);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array, final int size, final boolean copy) {
+        super(copy ? array.clone() : array, false);
+        this.size = size;
+    }
+
+    public static ExtendedDoubleArrayList getList(final double[] list, final int requiredLength) {
+        if (list.length == requiredLength) {
+            return new ExtendedDoubleArrayList(list, requiredLength, false);
+        } else {
+            return new ExtendedDoubleArrayList(Arrays.copyOf(list, requiredLength), requiredLength, false);
+        }
+    }
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedObjectAVLTreeSet.java b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedObjectAVLTreeSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a3f5963309f3464c7c8a37e0c46ab74165af88e
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/fastutil/ExtendedObjectAVLTreeSet.java
@@ -0,0 +1,90 @@
+package com.tuinity.tuinity.util.fastutil;
+
+import it.unimi.dsi.fastutil.objects.ObjectAVLTreeSet;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+
+import java.lang.reflect.Field;
+import java.util.function.Predicate;
+
+public class ExtendedObjectAVLTreeSet<K> extends ObjectAVLTreeSet<K> {
+
+    private static final Field PREV_FIELD;
+    private static final Field NEXT_FIELD;
+    private static final Field CURR_FIELD;
+    private static final Field INDEX_FIELD;
+
+    private static final Integer ZERO = Integer.valueOf(0);
+
+    static {
+        try {
+            final Class clazz = Class.forName(ObjectAVLTreeSet.class.getCanonicalName() + "$SetIterator");
+            PREV_FIELD = clazz.getDeclaredField("prev");
+            PREV_FIELD.setAccessible(true);
+
+            NEXT_FIELD = clazz.getDeclaredField("next");
+            NEXT_FIELD.setAccessible(true);
+
+            CURR_FIELD = clazz.getDeclaredField("curr");
+            CURR_FIELD.setAccessible(true);
+
+            INDEX_FIELD = clazz.getDeclaredField("index");
+            INDEX_FIELD.setAccessible(true);
+        } catch (final Throwable thr) {
+            throw new RuntimeException(thr);
+        }
+    }
+
+    private ObjectBidirectionalIterator<K> cachedIterator = this.iterator();
+
+    {
+        this.nullIterator(this.cachedIterator);
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super K> filter) {
+        if (this.isEmpty()) {
+            return false;
+        }
+
+        if (this.cachedIterator == null) {
+            return super.removeIf(filter); // recursive...?
+        }
+
+        final ObjectBidirectionalIterator<K> iterator = this.cachedIterator;
+        this.cachedIterator = null;
+        this.startIterator(iterator);
+
+        boolean ret = false;
+
+        while (iterator.hasNext()) {
+            if (filter.test(iterator.next())) {
+                ret = true;
+                iterator.remove();
+            }
+        }
+
+        this.nullIterator(iterator);
+        this.cachedIterator = iterator;
+        return ret;
+    }
+
+    private void startIterator(final ObjectBidirectionalIterator<K> iterator) {
+        // assume iterator is null'd
+        try {
+            NEXT_FIELD.set(iterator, this.firstEntry);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+
+    private void nullIterator(final ObjectBidirectionalIterator<K> iterator) {
+        try {
+            PREV_FIELD.set(iterator, null);
+            NEXT_FIELD.set(iterator, null);
+            CURR_FIELD.set(iterator, null);
+            INDEX_FIELD.set(iterator, ZERO);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/util/pool/PooledBlockPositions.java b/src/main/java/com/tuinity/tuinity/util/pool/PooledBlockPositions.java
new file mode 100644
index 0000000000000000000000000000000000000000..815974682ae0c6b0f1cf567b6fdc90017498da50
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/pool/PooledBlockPositions.java
@@ -0,0 +1,40 @@
+package com.tuinity.tuinity.util.pool;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MinecraftServer;
+
+public class PooledBlockPositions {
+
+    private static final int BLOCK_POOL_SIZE = 8192;
+
+    private static final BlockPosition.MutableBlockPosition[] POOL = new BlockPosition.MutableBlockPosition[BLOCK_POOL_SIZE];
+    private static int used = 0; // exclusive index of used positions
+
+    static {
+        for (int i = 0; i < BLOCK_POOL_SIZE; ++i) {
+            POOL[i] = new BlockPosition.MutableBlockPosition();
+        }
+    }
+
+    public static BlockPosition.MutableBlockPosition get(final int x, final int y, final int z) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed >= POOL.length) {
+            return new BlockPosition.MutableBlockPosition(x, y, z);
+        }
+        used = currentUsed + 1;
+
+        final BlockPosition.MutableBlockPosition ret = POOL[currentUsed];
+        POOL[currentUsed] = null;
+
+        return ret.setValues(x, y, z);
+    }
+
+    public static void ret(final BlockPosition.MutableBlockPosition position) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed == 0) {
+            return;
+        }
+
+        POOL[used = currentUsed - 1] = position;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e7fddb2fcdbc1877d1bdfe8d3c9eff6f..24ba03ae580858fde7c32c915bb447b97ea229a6 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        // Tuinity start - remove allocation of ChunkCoordIntPair
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        // Tuinity end
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        // Tuinity start - remove allocation of ChunkCoordIntPair
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        // Tuinity end
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 5919dbc3e14900db46c5090714a15c2f97c2fdf8..bde371e6a7a17fef224e045a569db51273c6b470 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import com.tuinity.tuinity.util.Util; // Tuinity
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
@@ -27,12 +28,12 @@ import org.apache.logging.log4j.Logger;
 public abstract class ChunkMapDistance {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2;
+    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2; public static int getPlayerTicketLevel() { return ChunkMapDistance.b; } // Tuinity - OBFHELPER
     private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
     public final Long2ObjectOpenHashMap<ArraySetSorted<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final ChunkMapDistance.a e = new ChunkMapDistance.a();
     private final ChunkMapDistance.b f = new ChunkMapDistance.b(8);
-    private final ChunkMapDistance.c g = new ChunkMapDistance.c(33);
+    //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); // Tuinity - no longer used
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.LinkedList<>(); // PAIL pendingChunkUpdates // Paper - use a queue
     private final ChunkTaskQueueSorter i;
     private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> j;
@@ -41,6 +42,69 @@ public abstract class ChunkMapDistance {
     private final Executor m;
     private long currentTick;
 
+    // Tuinity start
+    protected PlayerChunkMap chunkMap;
+    protected final ChunkMapDistance.TicketTracker playerTickViewDistanceHandler = new TicketTracker(ChunkMapDistance.getPlayerTicketLevel()) {
+        @Override
+        protected int tryQueueChunk(int chunkX, int chunkZ, EntityPlayer player) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            PlayerChunk currentChunk = ChunkMapDistance.this.chunkMap.chunkMap.getUpdating(coordinate);
+            if (currentChunk != null) {
+                Chunk fullChunk = currentChunk.getFullReadyChunk();
+                if (fullChunk != null && fullChunk.areNeighboursLoaded(2)) {
+                    this.chunkReferenceMap.putIfAbsent(coordinate, LOADED_PLAYER_REFERENCE);
+                    ChunkMapDistance.this.addTicket(coordinate, new Ticket<>(TicketType.PLAYER, this.ticketLevel, new ChunkCoordIntPair(chunkX, chunkZ)));
+                    return QUEUED;
+                }
+            }
+
+            return FAILED;
+        }
+
+        @Override
+        protected int getMaxChunkLoads(EntityPlayer player) {
+            return Integer.MAX_VALUE;
+        }
+    };
+
+    // this is copied from ChunkMapDistance.a(long, int, boolean, boolean), TODO check on update
+    // this is invoked if and only if there are no other players in range of the chunk.
+    public void playerMoveInRange(final int chunkX, final int chunkZ, final int fromX, final int fromZ) {
+        final long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+
+        final int dist = Math.max(Math.abs(chunkX - fromX), Math.abs(chunkZ - fromZ));
+        Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkCoordIntPair(chunkX, chunkZ));
+
+        ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+            ChunkMapDistance.this.m.execute(() -> {
+                if (ChunkMapDistance.this.chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(coordinate) != null) {
+                    ChunkMapDistance.this.addTicket(coordinate, ticket);
+                    ChunkMapDistance.this.l.add(coordinate);
+                } else {
+                    ChunkMapDistance.this.k.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+                    }, coordinate, false));
+                }
+            });
+        }, coordinate, () -> {
+            return dist;
+        }));
+    }
+
+    // this is copied from ChunkMapDistance.a(long, int, boolean, boolean), TODO check on update
+    // this is invoked if and only if there are no other players in range of the chunk.
+    public void playerMoveOutOfRange(final int chunkX, final int chunkZ, final int fromX, final int fromZ) {
+        final long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+
+        Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkCoordIntPair(chunkX, chunkZ));
+
+        ChunkMapDistance.this.k.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
+            ChunkMapDistance.this.m.execute(() -> {
+                ChunkMapDistance.this.removeTicket(coordinate, ticket);
+            });
+        }, coordinate, true));
+    }
+    // Tuinity end
+
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
         Mailbox<Runnable> mailbox = Mailbox.a("player ticket throttler", executor1::execute);
@@ -87,7 +151,7 @@ public abstract class ChunkMapDistance {
 
     public boolean a(PlayerChunkMap playerchunkmap) {
         this.f.a();
-        this.g.a();
+        //this.g.a(); // Tuinity - no longer used
         int i = Integer.MAX_VALUE - this.e.a(Integer.MAX_VALUE);
         boolean flag = i != 0;
 
@@ -225,7 +289,7 @@ public abstract class ChunkMapDistance {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
         this.f.b(i, 0, true);
-        this.g.b(i, 0, true);
+        //this.g.b(i, 0, true); // Tuinity - no longer used
     }
 
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
@@ -237,7 +301,7 @@ public abstract class ChunkMapDistance {
         if (objectset.isEmpty()) {
             this.c.remove(i);
             this.f.b(i, Integer.MAX_VALUE, false);
-            this.g.b(i, Integer.MAX_VALUE, false);
+            //this.g.b(i, Integer.MAX_VALUE, false); // Tuinity - no longer used
         }
 
     }
@@ -255,9 +319,16 @@ public abstract class ChunkMapDistance {
         return s;
     }
 
+    protected void setViewDistance(int viewDistance) { this.a(viewDistance); } // Tuinity - OBFHELPER
     protected void a(int i) {
-        this.g.a(i);
+        //this.g.a(i); // Tuinity - no longer used
+    }
+    // Tuinity start - per player view distance
+    protected void setGlobalViewDistance(int viewDistance, PlayerChunkMap chunkMap) {
+        this.chunkMap = chunkMap;
+        this.setViewDistance(viewDistance);
     }
+    // Tuinity end
 
     public int b() {
         this.f.a();
@@ -334,6 +405,222 @@ public abstract class ChunkMapDistance {
         }
     }
 
+    // Tuinity start - Per player view distance
+    abstract class TicketTracker {
+
+        static final int LOADED_PLAYER_REFERENCE = -2;
+
+        protected final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap chunkReferenceMap = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap(8192, 0.25f);
+        {
+            this.chunkReferenceMap.defaultReturnValue(-1);
+        }
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap lastLoadedRadiusByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        {
+            this.lastLoadedRadiusByPlayer.defaultReturnValue(-1);
+        }
+
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap pendingChunkLoadsByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        protected final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkPositionByPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+        {
+            this.lastChunkPositionByPlayer.defaultReturnValue(Long.MIN_VALUE);
+        }
+
+        protected final int ticketLevel;
+
+        public TicketTracker(int ticketLevel) {
+            this.ticketLevel = ticketLevel;
+        }
+
+        protected final java.util.List<EntityPlayer> players = new java.util.ArrayList<>(256);
+
+        protected com.tuinity.tuinity.util.map.PlayerAreaMap areaMap;
+
+        static final int ALREADY_QUEUED = 0;
+        static final int QUEUED = 1;
+        static final int FAILED = 2;
+
+        protected abstract int tryQueueChunk(int chunkX, int chunkZ, EntityPlayer player);
+
+        protected abstract int getMaxChunkLoads(EntityPlayer player);
+
+        public void tick() {
+            for (EntityPlayer player : this.players) {
+                int playerId = player.getId();
+                int lastLoadedRadius = this.lastLoadedRadiusByPlayer.get(playerId);
+                int pendingChunkLoads = this.pendingChunkLoadsByPlayer.get(playerId);
+                long lastChunkPos = this.lastChunkPositionByPlayer.get(playerId);
+                long currentChunkPos = this.areaMap.getLastCoordinate(player);
+
+                if (currentChunkPos == Long.MIN_VALUE) {
+                    // not tracking for whatever reason...
+                    continue;
+                }
+
+                int newX = Util.getCoordinateX(currentChunkPos);
+                int newZ = Util.getCoordinateZ(currentChunkPos);
+
+                // handle movement
+                if (currentChunkPos != lastChunkPos) {
+                    this.lastChunkPositionByPlayer.put(playerId, currentChunkPos);
+                    if (lastChunkPos != Long.MIN_VALUE) {
+                        int oldX = Util.getCoordinateX(lastChunkPos);
+                        int oldZ = Util.getCoordinateZ(lastChunkPos);
+
+                        int radiusDiff = Math.max(Math.abs(newX - oldX), Math.abs(newZ - oldZ));
+                        lastLoadedRadius = Math.max(-1, lastLoadedRadius - radiusDiff);
+                        this.lastLoadedRadiusByPlayer.put(playerId, lastLoadedRadius);
+                    }
+                }
+
+                int maxChunkLoads = this.getMaxChunkLoads(player);
+
+                int radius = lastLoadedRadius + 1;
+                int viewDistance = this.areaMap.getLastViewDistance(player);
+
+                if (radius > viewDistance) {
+                    // distance map will unload our chunks
+                    this.lastLoadedRadiusByPlayer.put(playerId, viewDistance);
+                    continue;
+                }
+
+                if (pendingChunkLoads >= maxChunkLoads) {
+                    continue;
+                }
+
+                radius_loop:
+                for (; radius <= viewDistance; ++radius) {
+                    for (int offset = 0; offset <= radius; ++offset) {
+                        // try to load the chunks closest to the player by distance
+                        // so instead of going left->right on the x axis, we start at the center of the view distance square
+                        // and go left and right at the same time
+
+                        // try top 2 chunks
+                        // top left
+                        int attempt = 0;
+                        if ((attempt = this.tryQueueChunk(newX - offset, newZ + radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // top right
+                        if ((attempt = this.tryQueueChunk(newX + offset, newZ + radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try bottom 2 chunks
+
+                        // bottom left
+                        if ((attempt = this.tryQueueChunk(newX - offset, newZ - radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // bottom right
+                        if ((attempt = this.tryQueueChunk(newX + offset, newZ - radius, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try left 2 chunks
+
+                        // left down
+                        if ((attempt = this.tryQueueChunk(newX - radius, newZ - offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // left up
+                        if ((attempt = this.tryQueueChunk(newX - radius, newZ + offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try right 2 chunks
+
+                        // right down
+                        if ((attempt = this.tryQueueChunk(newX + radius, newZ - offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // right up
+                        if ((attempt = this.tryQueueChunk(newX + radius, newZ + offset, player)) == QUEUED) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+                    }
+                }
+
+                int newLoadedRadius = radius - 1;
+                if (newLoadedRadius != lastLoadedRadius) {
+                    this.lastLoadedRadiusByPlayer.put(playerId, newLoadedRadius);
+                }
+                this.pendingChunkLoadsByPlayer.put(playerId, pendingChunkLoads);
+            }
+        }
+
+        public void addPlayer(EntityPlayer player) {
+            this.players.add(player);
+        }
+
+        public void removePlayer(EntityPlayer player) {
+            this.players.remove(player);
+            this.lastLoadedRadiusByPlayer.remove(player.getId());
+            this.pendingChunkLoadsByPlayer.remove(player.getId());
+            this.lastChunkPositionByPlayer.remove(player.getId());
+        }
+
+        public void onChunkLoad(int chunkX, int chunkZ) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.replace(coordinate, LOADED_PLAYER_REFERENCE);
+            if (playerReference != -1) {
+                this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                    return valueInMap - 1;
+                });
+            }
+        }
+
+        // this is invoked if and only if there are no other players in range of the chunk.
+        public void playerMoveOutOfRange(int chunkX, int chunkZ) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.remove(coordinate);
+            if (playerReference != -1) {
+                if (playerReference != LOADED_PLAYER_REFERENCE) {
+                    this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                        return valueInMap - 1;
+                    });
+                }
+                ChunkMapDistance.this.removeTicket(coordinate, new Ticket<>(TicketType.PLAYER, this.ticketLevel, new ChunkCoordIntPair(chunkX, chunkZ)));
+            }
+        }
+    }
+    // Tuinity end - per player view distance
+
     class c extends ChunkMapDistance.b {
 
         private int e = 0;
@@ -351,7 +638,7 @@ public abstract class ChunkMapDistance {
         }
 
         public void a(int i) {
-            ObjectIterator objectiterator = this.a.long2ByteEntrySet().iterator();
+            ObjectIterator objectiterator = this.a.long2ByteEntrySet().fastIterator(); // Tuinity - use fast iterator (reduces entry creation)
 
             while (objectiterator.hasNext()) {
                 it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
@@ -432,7 +719,7 @@ public abstract class ChunkMapDistance {
 
     class b extends ChunkMap {
 
-        protected final Long2ByteMap a = new Long2ByteOpenHashMap();
+        protected final Long2ByteOpenHashMap a = new Long2ByteOpenHashMap(); // Tuinity - change type for fast iterator
         protected final int b;
 
         protected b(int i) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 7da38954b334045ec9458d287d0b809a1c13b549..0149092b36381a14c0f120d1f61ef4e48e6ed511 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -604,6 +604,10 @@ public class ChunkProviderServer extends IChunkProvider {
         this.chunkMapDistance.purgeTickets();
         this.tickDistanceManager();
         this.world.timings.doChunkMap.stopTiming(); // Spigot
+        // Tuinity start
+        this.playerChunkMap.getChunkMapDistanceManager().playerTickViewDistanceHandler.tick();
+        this.playerChunkMap.chunkSendThrottler.tick();
+        // Tuinity end
         this.world.getMethodProfiler().exitEnter("chunks");
         this.world.timings.chunks.startTiming(); // Paper - timings
         this.tickChunks();
@@ -616,6 +620,12 @@ public class ChunkProviderServer extends IChunkProvider {
         this.clearCache();
     }
 
+    // Tuinity start
+    final com.tuinity.tuinity.util.ChunkList entityTickingChunks = new com.tuinity.tuinity.util.ChunkList();
+    boolean isTickingChunks;
+    final it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap<Chunk> pendingEntityTickingChunkChanges = new it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap<>(16, 0.8f);
+    // Tuinity end
+
     private void tickChunks() {
         long i = this.world.getTime();
         long j = i - this.lastTickTime;
@@ -668,11 +678,12 @@ public class ChunkProviderServer extends IChunkProvider {
                 entityPlayer.playerNaturallySpawnedEvent.callEvent();
             };
             // Paper end
-            this.playerChunkMap.f().forEach((playerchunk) -> {
-                Optional<Chunk> optional = ((Either) playerchunk.b().getNow(PlayerChunk.UNLOADED_CHUNK)).left();
-
-                if (optional.isPresent()) {
-                    Chunk chunk = (Chunk) optional.get();
+            // Tuinity start - replace chunk map
+            this.isTickingChunks = true;
+            for (Chunk chunk : this.entityTickingChunks) {
+                PlayerChunk playerchunk = chunk.playerChunk;
+                if (playerchunk != null) { // make sure load event has been called along with the load logic we put there
+                    // Tuinity end
 
                     this.world.getMethodProfiler().enter("broadcast");
                     this.world.timings.broadcastChunkUpdates.startTiming(); // Paper - timings
@@ -767,7 +778,22 @@ public class ChunkProviderServer extends IChunkProvider {
                         this.world.timings.chunkTicks.stopTiming(); // Spigot // Paper
                     }
                 }
-            });
+            }; // Tuinity
+            // Tuinity start - replace chunk map
+            this.isTickingChunks = false;
+            if (!this.pendingEntityTickingChunkChanges.isEmpty()) {
+                for (it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator<it.unimi.dsi.fastutil.objects.Object2BooleanMap.Entry<Chunk>> iterator = this.pendingEntityTickingChunkChanges.object2BooleanEntrySet().fastIterator(this.pendingEntityTickingChunkChanges.object2BooleanEntrySet().last()); iterator.hasPrevious(); ) {
+                    it.unimi.dsi.fastutil.objects.Object2BooleanMap.Entry<Chunk> entry = iterator.previous();
+
+                    if (entry.getBooleanValue()) {
+                        this.entityTickingChunks.add(entry.getKey());
+                    } else {
+                        this.entityTickingChunks.remove(entry.getKey());
+                    }
+                    iterator.remove();
+                }
+            }
+            // Tuinity end - replace chunk map
             this.world.getMethodProfiler().enter("customSpawners");
             if (flag1) {
                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings
diff --git a/src/main/java/net/minecraft/server/ChunkStatus.java b/src/main/java/net/minecraft/server/ChunkStatus.java
index 88f1674616ef0af9d7491402ce672125f4b7fe83..25654520e7300fe5b1a4e5c445fcb142aa139bcf 100644
--- a/src/main/java/net/minecraft/server/ChunkStatus.java
+++ b/src/main/java/net/minecraft/server/ChunkStatus.java
@@ -103,7 +103,7 @@ public class ChunkStatus {
     private final ChunkStatus.c w;
     private final int x;
     private final ChunkStatus.Type y;
-    private final EnumSet<HeightMap.Type> z;
+    private final EnumSet<HeightMap.Type> z; public final HeightMap.Type[] heightMaps; // Tuinity
 
     private static CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(ChunkStatus chunkstatus, LightEngineThreaded lightenginethreaded, IChunkAccess ichunkaccess) {
         boolean flag = a(chunkstatus, ichunkaccess);
@@ -165,7 +165,7 @@ public class ChunkStatus {
         this.w = chunkstatus_c;
         this.x = i;
         this.y = chunkstatus_type;
-        this.z = enumset;
+        this.z = enumset; this.heightMaps = new java.util.ArrayList<>(this.z).toArray(new HeightMap.Type[0]); // Tuinity
         this.t = chunkstatus == null ? 0 : chunkstatus.c() + 1;
     }
 
diff --git a/src/main/java/net/minecraft/server/DoubleListOffset.java b/src/main/java/net/minecraft/server/DoubleListOffset.java
index 73657f740731b9bc606e64d0a2a3f32a842db3f5..9ff09b02d6d0f26d935797f41eb99ec7a9c3d94f 100644
--- a/src/main/java/net/minecraft/server/DoubleListOffset.java
+++ b/src/main/java/net/minecraft/server/DoubleListOffset.java
@@ -3,7 +3,7 @@ package net.minecraft.server;
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 
-public class DoubleListOffset extends AbstractDoubleList {
+public class DoubleListOffset extends com.tuinity.tuinity.util.fastutil.ExtendedAbstractDoubleList { // Tuinity - remove iterator allocation
 
     private final DoubleList a;
     private final double b;
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index af10fc36e0a91c07f037da4b4081fe081fab82ae..bf14d33c0dda2861fdb2cbab19358b66495d16e9 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -579,9 +579,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API // Tuinity - per player view distance
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) << 4; // Tuinity - per player view distance
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index fdaad67553a18d0e4fb6e2c9be36ee4eda7eb663..3d37d54200c65449b9e7df77161aba5cd2ecde85 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -108,6 +108,33 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public final com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> cachedSingleHashSetTuinity;
     // Tuinity end
 
+    // Tuinity start - view distance api
+    final it.unimi.dsi.fastutil.longs.LongOpenHashSet loadedChunks = new it.unimi.dsi.fastutil.longs.LongOpenHashSet();
+
+    boolean needsChunkCenterUpdate;
+    int viewDistance = -1;
+    public final int getRawViewDistance() {
+        return this.viewDistance;
+    }
+    public final int getEffectiveViewDistance() {
+        return this.getEffectiveViewDistance(((WorldServer)this.world).getChunkProvider().playerChunkMap);
+    }
+    public final int getEffectiveViewDistance(PlayerChunkMap chunkMap) {
+        return this.viewDistance == -1 ? chunkMap.viewDistance : this.viewDistance;
+    }
+
+    int noTickViewDistance = -1;
+    public final int getRawNoTickViewDistance() {
+        return this.noTickViewDistance;
+    }
+    public final int getEffectiveNoTickViewDistance() {
+        return this.getEffectiveNoTickViewDistance(((WorldServer)this.world).getChunkProvider().playerChunkMap);
+    }
+    public final int getEffectiveNoTickViewDistance(PlayerChunkMap chunkMap) {
+        return this.noTickViewDistance == -1 ? chunkMap.noTickViewDistance : this.noTickViewDistance;
+    }
+    // Tuinity end - view distance api
+
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super((World) worldserver, gameprofile);
         playerinteractmanager.player = this;
@@ -1780,8 +1807,13 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void a(ChunkCoordIntPair chunkcoordintpair) {
+        // Tuinity start - remove ChunkCoordIntPair allocation
+        this.sendChunkUnload(chunkcoordintpair.x, chunkcoordintpair.z);
+    }
+    public final void sendChunkUnload(int x, int z) {
+        // Tuinity end - remove ChunkCoordIntPair allocation
         if (this.isAlive()) {
-            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkcoordintpair.x, chunkcoordintpair.z));
+            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(x, z)); // Tuinity
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 3e5d6a9e151fb990b777c1ac48cabea653ea1c27..40d6e8bf7c34d91bbc44d23efc498daa4f61b7e2 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -125,8 +125,10 @@ public class EntityTrackerEntry {
                 ++this.o;
                 i = MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
                 j = MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
-                Vec3D vec3d = this.tracker.getPositionVector().d(PacketPlayOutEntity.a(this.xLoc, this.yLoc, this.zLoc));
-                boolean flag1 = vec3d.g() >= 7.62939453125E-6D;
+                double vec3d_dx = this.tracker.locX() - 2.44140625E-4D*(this.xLoc);
+                double vec3d_dy = this.tracker.locY() - 2.44140625E-4D*(this.yLoc);
+                double vec3d_dz = this.tracker.locZ() - 2.44140625E-4D*(this.zLoc);
+                boolean flag1 = (vec3d_dx * vec3d_dx + vec3d_dy * vec3d_dy + vec3d_dz * vec3d_dz) >= 7.62939453125E-6D;
                 Packet<?> packet1 = null;
                 boolean flag2 = flag1 || this.tickCounter % 60 == 0;
                 boolean flag3 = Math.abs(i - this.yRot) >= 1 || Math.abs(j - this.xRot) >= 1;
@@ -143,9 +145,11 @@ public class EntityTrackerEntry {
                 // CraftBukkit end
 
                 if (this.tickCounter > 0 || this.tracker instanceof EntityArrow) {
-                    long k = PacketPlayOutEntity.a(vec3d.x);
-                    long l = PacketPlayOutEntity.a(vec3d.y);
-                    long i1 = PacketPlayOutEntity.a(vec3d.z);
+                    // Tuinity start - remove allocation of Vec3d here
+                    long k = PacketPlayOutEntity.a(vec3d_dx);
+                    long l = PacketPlayOutEntity.a(vec3d_dy);
+                    long i1 = PacketPlayOutEntity.a(vec3d_dz);
+                    // Tuinity end - remove allocation of Vec3d here
                     boolean flag4 = k < -32768L || k > 32767L || l < -32768L || l > 32767L || i1 < -32768L || i1 > 32767L;
 
                     if (!flag4 && this.o <= 400 && !this.q && this.r == this.tracker.onGround) {
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8977c3516b2ee9b970b6274a5c71982b019ac2a6..bace6cf36a9e888278a6c7a5c5866d9f3b9ecf87 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API // Tuinity - per player view distance
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) << 4; // Tuinity - per player view distance
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/LightEngineBlock.java b/src/main/java/net/minecraft/server/LightEngineBlock.java
index 93a972605c26aa757b9c915876f847da04fcb496..43424c88ab830281bcfd7594e1100831050ec608 100644
--- a/src/main/java/net/minecraft/server/LightEngineBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineBlock.java
@@ -37,7 +37,7 @@ public final class LightEngineBlock extends LightEngineLayer<LightEngineStorageB
             if (enumdirection == null) {
                 return 15;
             } else {
-                MutableInt mutableint = new MutableInt();
+                MutableInt mutableint = this.lastLevel; // Tuinity - avoid allocation of MutableInt
                 IBlockData iblockdata = this.a(j, mutableint);
 
                 if (mutableint.getValue() >= 15) {
diff --git a/src/main/java/net/minecraft/server/LightEngineLayer.java b/src/main/java/net/minecraft/server/LightEngineLayer.java
index f72ff8495bcf704c15040676b95c51fecb72b73a..f27a148731fb71f85265396b345c6306a1f1b2d0 100644
--- a/src/main/java/net/minecraft/server/LightEngineLayer.java
+++ b/src/main/java/net/minecraft/server/LightEngineLayer.java
@@ -11,7 +11,7 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
     protected final EnumSkyBlock b;
     protected final S c;
     private boolean f;
-    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition();
+    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition(); protected final MutableInt lastLevel = new MutableInt(); // Tuinity - avoid allocating MutableInt
     private final long[] g = new long[2];
     private final IBlockAccess[] h = new IBlockAccess[2];
 
diff --git a/src/main/java/net/minecraft/server/LightEngineSky.java b/src/main/java/net/minecraft/server/LightEngineSky.java
index 2301a982e17ab9568e3da9ca84c4a024c7c1b214..488d4f289f0934022c7fb040350eb1450e8cc167 100644
--- a/src/main/java/net/minecraft/server/LightEngineSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineSky.java
@@ -27,7 +27,7 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
             if (k >= 15) {
                 return k;
             } else {
-                MutableInt mutableint = new MutableInt();
+                MutableInt mutableint = this.lastLevel; // Tuinity - avoid allocation of MutableInt
                 IBlockData iblockdata = this.a(j, mutableint);
 
                 if (mutableint.getValue() >= 15) {
diff --git a/src/main/java/net/minecraft/server/LightEngineStorage.java b/src/main/java/net/minecraft/server/LightEngineStorage.java
index a3f919816eb2a742ed09b553995e6508684e5ea5..dacc96414f6b381700c72a0f61af3f8e517a2b62 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorage.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorage.java
@@ -19,11 +19,12 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
     protected final LongSet b = new LongOpenHashSet();
     protected final LongSet c = new LongOpenHashSet();
     protected final LongSet d = new LongOpenHashSet();
-    protected volatile M e;
-    protected final M f;
+    protected volatile M e; // Tuinity - diff on change, should be "visible"
+    protected final M f; // Tuinity - diff on change, should be "updating"
     protected final LongSet g = new LongOpenHashSet();
     protected final LongSet h = new LongOpenHashSet();
-    protected final Long2ObjectMap<NibbleArray> i = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap());
+    protected final Long2ObjectOpenHashMap<NibbleArray> synchronized_map_real = new Long2ObjectOpenHashMap<>(); // Tuinity - store wrapped map, we need fastIterator
+    protected final Long2ObjectMap<NibbleArray> i = Long2ObjectMaps.synchronize(this.synchronized_map_real); // Tuinity - store wrapped map, we need fastIterator
     private final LongSet n = new LongOpenHashSet();
     private final LongSet o = new LongOpenHashSet();
     protected volatile boolean j;
@@ -178,7 +179,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
             NibbleArray nibblearray;
 
             while (longiterator.hasNext()) {
-                i = (Long) longiterator.next();
+                i = longiterator.nextLong(); // Tuinity - use nextLong
                 this.a(lightenginelayer, i);
                 NibbleArray nibblearray1 = (NibbleArray) this.i.remove(i);
 
@@ -196,13 +197,13 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
             longiterator = this.o.iterator();
 
             while (longiterator.hasNext()) {
-                i = (Long) longiterator.next();
+                i = longiterator.nextLong(); // Tuinity - use nextLong
                 this.l(i);
             }
 
             this.o.clear();
             this.j = false;
-            ObjectIterator objectiterator = this.i.long2ObjectEntrySet().iterator();
+            ObjectIterator objectiterator = this.synchronized_map_real.long2ObjectEntrySet().fastIterator(); // Tuinity - use fast iterator to reduce entry creation
 
             Entry entry;
             long j;
@@ -225,7 +226,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
                 longiterator = this.i.keySet().iterator();
 
                 while (longiterator.hasNext()) {
-                    i = (Long) longiterator.next();
+                    i = longiterator.nextLong(); // Tuinity - use nextLong
                     if (this.g(i)) {
                         int k = SectionPosition.c(SectionPosition.b(i));
                         int l = SectionPosition.c(SectionPosition.c(i));
@@ -279,7 +280,7 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
                 }
             }
 
-            objectiterator = this.i.long2ObjectEntrySet().iterator();
+            objectiterator = this.synchronized_map_real.long2ObjectEntrySet().fastIterator(); // Tuinity - use fast iterator to avoid entry creation
 
             while (objectiterator.hasNext()) {
                 entry = (Entry) objectiterator.next();
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageArray.java b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
index b978723a66d001f70325df0c7521025e079d7cfa..5e2051ee1a27b56db010d1ffc16c7e1c1d6d7564 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageArray.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
@@ -8,10 +8,17 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     private final long[] b = new long[2];
     private final NibbleArray[] c = new NibbleArray[2];
     private boolean d;
-    protected final Long2ObjectOpenHashMap<NibbleArray> a;
+    protected final com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> data; // Tuinity - avoid copying light data
+    protected final boolean isVisible; // Tuinity - avoid copying light data
 
-    protected LightEngineStorageArray(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-        this.a = long2objectopenhashmap;
+    // Tuinity start - avoid copying light data
+    protected LightEngineStorageArray(com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> data, boolean isVisible) {
+        if (isVisible) {
+            data.performUpdatesLockMap();
+        }
+        this.data = data;
+        this.isVisible = isVisible;
+        // Tuinity end - avoid copying light data
         this.c();
         this.d = true;
     }
@@ -19,12 +26,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     public abstract M b();
 
     public void a(long i) {
-        this.a.put(i, ((NibbleArray) this.a.get(i)).b());
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Tuinity - avoid copying light data
+        this.data.queueUpdate(i, ((NibbleArray) this.data.getUpdating(i)).b()); // Tuinity - avoid copying light data
         this.c();
     }
 
     public boolean b(long i) {
-        return this.a.containsKey(i);
+        return this.isVisible ? this.data.getVisibleAsync(i) != null : this.data.getUpdating(i) != null; // Tuinity - avoid copying light data
     }
 
     @Nullable
@@ -37,7 +45,7 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
             }
         }
 
-        NibbleArray nibblearray = (NibbleArray) this.a.get(i);
+        NibbleArray nibblearray = (NibbleArray) (this.isVisible ? this.data.getVisibleAsync(i) : this.data.getUpdating(i)); // Tuinity - avoid copying light data
 
         if (nibblearray == null) {
             return null;
@@ -58,11 +66,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
 
     @Nullable
     public NibbleArray d(long i) {
-        return (NibbleArray) this.a.remove(i);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Tuinity - avoid copying light data
+        return (NibbleArray) this.data.queueRemove(i); // Tuinity - avoid copying light data
     }
 
     public void a(long i, NibbleArray nibblearray) {
-        this.a.put(i, nibblearray);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } // Tuinity - avoid copying light data
+        this.data.queueUpdate(i, nibblearray); // Tuinity - avoid copying light data
     }
 
     public void c() {
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
index 0f7f4744d9f9e5174fb38ccc72248397a4b064ea..21a15c3b3a861d807ac9256c75e1ff67f33e1dd8 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
@@ -5,7 +5,7 @@ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStorageBlock.a> {
 
     protected LightEngineStorageBlock(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new Long2ObjectOpenHashMap()));
+        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<>(), false)); // Tuinity - avoid copying light data
     }
 
     @Override
@@ -18,13 +18,13 @@ public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStora
 
     public static final class a extends LightEngineStorageArray<LightEngineStorageBlock.a> {
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-            super(long2objectopenhashmap);
+        public a(com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> long2objectopenhashmap, boolean isVisible) { // Tuinity - avoid copying light data
+            super(long2objectopenhashmap, isVisible); // Tuinity - avoid copying light data
         }
 
         @Override
         public LightEngineStorageBlock.a b() {
-            return new LightEngineStorageBlock.a(this.a.clone());
+            return new a(this.data, true); // Tuinity - avoid copying light data
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageSky.java b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
index 75d9065b32731dc635d9d09c48fb9643172381a9..4669f31b04d98e8369606d9bedf9c0ccc82e4c00 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
@@ -17,7 +17,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     private volatile boolean p;
 
     protected LightEngineStorageSky(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new Long2ObjectOpenHashMap(), new Long2IntOpenHashMap(), Integer.MAX_VALUE));
+        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<>(), new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Int(), Integer.MAX_VALUE, false)); // Tuinity - avoid copying light data
     }
 
     @Override
@@ -25,7 +25,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
         long j = SectionPosition.e(i);
         int k = SectionPosition.c(j);
         LightEngineStorageSky.a lightenginestoragesky_a = (LightEngineStorageSky.a) this.e;
-        int l = lightenginestoragesky_a.c.get(SectionPosition.f(j));
+        int l = lightenginestoragesky_a.otherData.getVisibleAsync(SectionPosition.f(j)); // Tuinity - avoid copying light data
 
         if (l != lightenginestoragesky_a.b && k < l) {
             NibbleArray nibblearray = this.a(lightenginestoragesky_a, j); // Paper - decompile fix
@@ -54,14 +54,14 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         if (((LightEngineStorageSky.a) this.f).b > j) {
             ((LightEngineStorageSky.a) this.f).b = j;
-            ((LightEngineStorageSky.a) this.f).c.defaultReturnValue(((LightEngineStorageSky.a) this.f).b);
+            ((LightEngineStorageSky.a) this.f).otherData.queueDefaultReturnValue(((LightEngineStorageSky.a) this.f).b); // Tuinity - avoid copying light data
         }
 
         long k = SectionPosition.f(i);
-        int l = ((LightEngineStorageSky.a) this.f).c.get(k);
+        int l = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(k); // Tuinity - avoid copying light data
 
         if (l < j + 1) {
-            ((LightEngineStorageSky.a) this.f).c.put(k, j + 1);
+            ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(k, j + 1); // Tuinity - avoid copying light data
             if (this.o.contains(k)) {
                 this.q(i);
                 if (l > ((LightEngineStorageSky.a) this.f).b) {
@@ -101,7 +101,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         int k = SectionPosition.c(i);
 
-        if (((LightEngineStorageSky.a) this.f).c.get(j) == k + 1) {
+        if (((LightEngineStorageSky.a) this.f).otherData.getUpdating(j) == k + 1) { // Tuinity - avoid copying light data
             long l;
 
             for (l = i; !this.g(l) && this.a(k); l = SectionPosition.a(l, EnumDirection.DOWN)) {
@@ -109,12 +109,12 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             }
 
             if (this.g(l)) {
-                ((LightEngineStorageSky.a) this.f).c.put(j, k + 1);
+                ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(j, k + 1); // Tuinity - avoid copying light data
                 if (flag) {
                     this.q(l);
                 }
             } else {
-                ((LightEngineStorageSky.a) this.f).c.remove(j);
+                ((LightEngineStorageSky.a) this.f).otherData.queueRemove(j); // Tuinity - avoid copying light data
             }
         }
 
@@ -128,7 +128,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     protected void b(long i, boolean flag) {
         this.d();
         if (flag && this.o.add(i)) {
-            int j = ((LightEngineStorageSky.a) this.f).c.get(i);
+            int j = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(i); // Tuinity - avoid copying light data
 
             if (j != ((LightEngineStorageSky.a) this.f).b) {
                 long k = SectionPosition.b(SectionPosition.b(i), j - 1, SectionPosition.d(i));
@@ -155,7 +155,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             return nibblearray;
         } else {
             long j = SectionPosition.a(i, EnumDirection.UP);
-            int k = ((LightEngineStorageSky.a) this.f).c.get(SectionPosition.f(i));
+            int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(SectionPosition.f(i)); // Tuinity - avoid copying light data
 
             if (k != ((LightEngineStorageSky.a) this.f).b && SectionPosition.c(j) < k) {
                 NibbleArray nibblearray1;
@@ -298,7 +298,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             if (!this.o.contains(l)) {
                 return false;
             } else {
-                int i1 = ((LightEngineStorageSky.a) this.f).c.get(l);
+                int i1 = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(l); // Tuinity - avoid copying light data
 
                 return SectionPosition.c(i1) == j + 16;
             }
@@ -307,7 +307,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
     protected boolean n(long i) {
         long j = SectionPosition.f(i);
-        int k = ((LightEngineStorageSky.a) this.f).c.get(j);
+        int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(j); // Tuinity - avoid copying light data
 
         return k == ((LightEngineStorageSky.a) this.f).b || SectionPosition.c(i) >= k;
     }
@@ -321,18 +321,20 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     public static final class a extends LightEngineStorageArray<LightEngineStorageSky.a> {
 
         private int b;
-        private final Long2IntOpenHashMap c;
+        private final com.tuinity.tuinity.chunk.QueuedChangesMapLong2Int otherData; // Tuinity - avoid copying light data
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap, Long2IntOpenHashMap long2intopenhashmap, int i) {
-            super(long2objectopenhashmap);
-            this.c = long2intopenhashmap;
-            long2intopenhashmap.defaultReturnValue(i);
+        // Tuinity start - avoid copying light data
+        public a(com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<NibbleArray> data, com.tuinity.tuinity.chunk.QueuedChangesMapLong2Int otherData, int i, boolean isVisible) {
+            super(data, isVisible);
+            this.otherData = otherData;
+            // Tuinity end - avoid copying light data
             this.b = i;
         }
 
         @Override
         public LightEngineStorageSky.a b() {
-            return new LightEngineStorageSky.a(this.a.clone(), this.c.clone(), this.b);
+            this.otherData.performUpdatesLockMap(); // Tuinity - avoid copying light data
+            return new LightEngineStorageSky.a(this.data, this.otherData, this.b, true); // Tuinity - avoid copying light data
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index b9d58445205c009d2cbc81db88449f3b40b21377..d1412760dde071f195fdf7070302d27a937d6937 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -500,9 +500,9 @@ public final class MCUtil {
 
             WorldServer world = ((org.bukkit.craftbukkit.CraftWorld)bukkitWorld).getHandle();
             PlayerChunkMap chunkMap = world.getChunkProvider().playerChunkMap;
-            Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks = chunkMap.visibleChunks;
+            // Tuinity - replace chunk map
             ChunkMapDistance chunkMapDistance = chunkMap.getChunkMapDistanceManager();
-            List<PlayerChunk> allChunks = new ArrayList<>(visibleChunks.values());
+            List<PlayerChunk> allChunks = chunkMap.chunkMap.getUpdatingValuesCopy(); // Tuinity - replace chunk map
             List<EntityPlayer> players = world.players;
 
             int fullLoadedChunks = 0;
@@ -525,7 +525,7 @@ public final class MCUtil {
             worldData.addProperty("view-distance", world.spigotConfig.viewDistance);
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig.keepLoadedRange);
-            worldData.addProperty("visible-chunk-count", visibleChunks.size());
+            worldData.addProperty("visible-chunk-count", allChunks.size()); // Tuinity - replace chunk map
             worldData.addProperty("loaded-chunk-count", chunkMap.loadedChunks.size());
             worldData.addProperty("verified-fully-loaded-chunks", fullLoadedChunks);
 
@@ -603,4 +603,28 @@ public final class MCUtil {
         // TODO make sure the constant `33` is correct on future updates. See getChunkAt(int, int, ChunkStatus, boolean)
         return 33 + ChunkStatus.getTicketLevelOffset(status);
     }
+
+    public static <E> boolean hasCommonElement(Set<E> set0, Set<E> set1) {
+        java.util.Iterator<E> iterator;
+        Set<E> target;
+
+        // optimize by iterating over fewest entries possible
+        if (set0.size() <= set1.size()) {
+            target = set1;
+            iterator = set0.iterator();
+        } else {
+            target = set0;
+            iterator = set1.iterator();
+        }
+
+        while (iterator.hasNext()) {
+            E element = iterator.next();
+            if (target.contains(element)) {
+                return true;
+            }
+        }
+
+        return false;
+
+    }
 }
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index 98deaba12ceb25f59d1b56420fb544a64b417ddd..fcc3b7c36ba20826ad1e9be153a906384ecc4d2d 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -67,7 +67,7 @@ public class NBTTagCompound implements NBTBase {
     }
 
     public NBTTagCompound() {
-        this(Maps.newHashMap());
+        this(new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(16, 0.8f)); // Tuinity - reduce memory footprint of NBTTagCompound
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/PairedQueue.java b/src/main/java/net/minecraft/server/PairedQueue.java
index 85bb22e4b7376b676139048f2d55684e27a54055..1e618446a4cf08c86296aadf356d0363e047e12d 100644
--- a/src/main/java/net/minecraft/server/PairedQueue.java
+++ b/src/main/java/net/minecraft/server/PairedQueue.java
@@ -20,32 +20,30 @@ public interface PairedQueue<T, F> {
 
     public static final class a implements PairedQueue<PairedQueue.b, Runnable> {
 
-        private final List<Queue<Runnable>> a;
+        private final List<Queue<Runnable>> a; private final List<Queue<Runnable>> getQueues() { return this.a; } // Tuinity - OBFHELPER
 
         public a(int i) {
-            this.a = (List) IntStream.range(0, i).mapToObj((j) -> {
-                return Queues.newConcurrentLinkedQueue();
-            }).collect(Collectors.toList());
+            // Tuinity start - reduce streams
+            this.a = new java.util.ArrayList<>(i); // queues
+            for (int j = 0; j < i; ++j) {
+                this.getQueues().add(new ca.spottedleaf.concurrentutil.queue.MultiThreadedQueue<>()); // use MT queue
+            }
+            // Tuinity end - reduce streams
         }
 
         @Nullable
         @Override
         public Runnable a() {
-            Iterator iterator = this.a.iterator();
-
-            Runnable runnable;
-
-            do {
-                if (!iterator.hasNext()) {
-                    return null;
+            // Tuinity start - reduce iterator creation
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                Runnable ret = queue.poll();
+                if (ret != null) {
+                    return ret;
                 }
-
-                Queue<Runnable> queue = (Queue) iterator.next();
-
-                runnable = (Runnable) queue.poll();
-            } while (runnable == null);
-
-            return runnable;
+            }
+            return null;
+            // Tuinity end - reduce iterator creation
         }
 
         public boolean a(PairedQueue.b pairedqueue_b) {
@@ -57,7 +55,15 @@ public interface PairedQueue<T, F> {
 
         @Override
         public boolean b() {
-            return this.a.stream().allMatch(Collection::isEmpty);
+            // Tuinity start - reduce streams
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                if (!queue.isEmpty()) {
+                    return false;
+                }
+            }
+            return true;
+            // Tuinity end - reduce streams
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderGoal.java b/src/main/java/net/minecraft/server/PathfinderGoal.java
index bdb90a346639db37d3c72359c28b72d021d1b389..738c510706089f46551f1884a0accc147c07836c 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoal.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoal.java
@@ -1,10 +1,11 @@
 package net.minecraft.server;
 
+import com.tuinity.tuinity.util.OptimizedSmallEnumSet; // Tuinity
 import java.util.EnumSet;
 
 public abstract class PathfinderGoal {
 
-    private final EnumSet<PathfinderGoal.Type> a = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); // Tuinity - reduce garbage on heap
 
     public PathfinderGoal() {}
 
@@ -28,16 +29,20 @@ public abstract class PathfinderGoal {
     public void e() {}
 
     public void a(EnumSet<PathfinderGoal.Type> enumset) {
-        this.a.clear();
-        this.a.addAll(enumset);
+        // Tuinity start - reduce garbage on heap
+        this.goalTypes.clear();
+        this.goalTypes.addAllUnchecked(enumset);
+        // Tuinity end - reduce garbage on heap
     }
 
     public String toString() {
         return this.getClass().getSimpleName();
     }
 
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a;
+    // Tuinity start - reduce garbage on heap
+    public com.tuinity.tuinity.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.goalTypes;
+        // Tuinity end - reduce garbage on heap
     }
 
     public static enum Type {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
index 935136771e776fe498f608a159a41393340adc4e..782edcb63b8e7d181acfc2998ddaf8e7120fa7f5 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import com.tuinity.tuinity.util.OptimizedSmallEnumSet;
 import com.google.common.collect.Sets;
 import java.util.EnumMap;
 import java.util.EnumSet;
+import java.util.Iterator; // Tuinity
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Stream;
@@ -26,7 +28,7 @@ public class PathfinderGoalSelector {
     private final Map<PathfinderGoal.Type, PathfinderGoalWrapped> c = new EnumMap(PathfinderGoal.Type.class);
     private final Set<PathfinderGoalWrapped> d = Sets.newLinkedHashSet();private Set<PathfinderGoalWrapped> getTasks() { return d; }// Paper - OBFHELPER
     private final GameProfilerFiller e;
-    private final EnumSet<PathfinderGoal.Type> f = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<PathfinderGoal.Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); // Tuinity - reduce garbage on heap
     private int g = 3;private int getTickRate() { return g; } // Paper - OBFHELPER
     private int curRate;private int getCurRate() { return curRate; } private void incRate() { this.curRate++; } // Paper TODO
 
@@ -58,33 +60,38 @@ public class PathfinderGoalSelector {
     // Paper end
 
     public void a(PathfinderGoal pathfindergoal) {
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        }).filter(PathfinderGoalWrapped::g).forEach(PathfinderGoalWrapped::d);
-        this.d.removeIf((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        });
+        // Tuinity start - remove streams
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped goalWrapped = iterator.next();
+            if (goalWrapped.j() != pathfindergoal) {
+                continue;
+            }
+            if (goalWrapped.g()) {
+                goalWrapped.d();
+            }
+            iterator.remove();
+        }
+        // Tuinity end
     }
 
+    private static final PathfinderGoal.Type[] PATHFINDER_GOAL_TYPES = PathfinderGoal.Type.values();
+
     public void doTick() {
         this.e.enter("goalCleanup");
-        this.c().filter((pathfindergoalwrapped) -> {
-            boolean flag;
-
-            if (pathfindergoalwrapped.g()) {
-                Stream stream = pathfindergoalwrapped.i().stream();
-                EnumSet enumset = this.f;
+        // Tuinity start - remove streams
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (!wrappedGoal.g()) {
+                continue;
+            }
 
-                this.f.getClass();
-                if (!stream.anyMatch(enumset::contains) && pathfindergoalwrapped.b()) {
-                    flag = false;
-                    return flag;
-                }
+            if (!this.goalTypes.hasCommonElements(wrappedGoal.getGoalTypes()) && wrappedGoal.b()) {
+                continue;
             }
 
-            flag = true;
-            return flag;
-        }).forEach(PathfinderGoal::d);
+            wrappedGoal.d();
+        }
+        // Tuinity end
         this.c.forEach((pathfindergoal_type, pathfindergoalwrapped) -> {
             if (!pathfindergoalwrapped.g()) {
                 this.c.remove(pathfindergoal_type);
@@ -93,30 +100,58 @@ public class PathfinderGoalSelector {
         });
         this.e.exit();
         this.e.enter("goalUpdate");
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return !pathfindergoalwrapped.g();
-        }).filter((pathfindergoalwrapped) -> {
-            Stream stream = pathfindergoalwrapped.i().stream();
-            EnumSet enumset = this.f;
-
-            this.f.getClass();
-            return stream.noneMatch(enumset::contains);
-        }).filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.i().stream().allMatch((pathfindergoal_type) -> {
-                return ((PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b)).a(pathfindergoalwrapped);
-            });
-        }).filter(PathfinderGoalWrapped::a).forEach((pathfindergoalwrapped) -> {
-            pathfindergoalwrapped.i().forEach((pathfindergoal_type) -> {
-                PathfinderGoalWrapped pathfindergoalwrapped1 = (PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b);
-
-                pathfindergoalwrapped1.d();
-                this.c.put(pathfindergoal_type, pathfindergoalwrapped);
-            });
-            pathfindergoalwrapped.c();
-        });
+        // Tuinity start - remove streams
+        goal_update_loop: for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                continue;
+            }
+
+            OptimizedSmallEnumSet<PathfinderGoal.Type> wrappedGoalSet = wrappedGoal.getGoalTypes();
+
+            if (this.goalTypes.hasCommonElements(wrappedGoalSet)) {
+                continue;
+            }
+
+            long iterator1 = wrappedGoalSet.getBackingSet();
+            int wrappedGoalSize = wrappedGoalSet.size();
+            for (int i = 0; i < wrappedGoalSize; ++i) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+                if (!wrapped.a(wrappedGoal)) {
+                    continue goal_update_loop;
+                }
+            }
+
+            if (!wrappedGoal.a()) {
+                continue;
+            }
+
+            iterator1 = wrappedGoalSet.getBackingSet();
+            wrappedGoalSize = wrappedGoalSet.size();
+            for (int i = 0; i < wrappedGoalSize; ++i) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+
+                wrapped.d();
+                this.c.put(type, wrappedGoal);
+            }
+
+            wrappedGoal.c();
+        }
+        // Tuinity end
         this.e.exit();
         this.e.enter("goalTick");
-        this.c().forEach(PathfinderGoalWrapped::e);
+        // Tuinity start - remove streams
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                wrappedGoal.e();
+            }
+        }
+        // Tuinity end
         this.e.exit();
     }
 
@@ -125,11 +160,11 @@ public class PathfinderGoalSelector {
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.add(pathfindergoal_type);
+        this.goalTypes.addUnchecked(pathfindergoal_type); // Tuinity - reduce streams
     }
 
     public void b(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.remove(pathfindergoal_type);
+        this.goalTypes.removeUnchecked(pathfindergoal_type); // Tuinity - reduce streams
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type, boolean flag) {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
index 29657fed75184aee0c89e56f5e642a5d68eda444..71919adc0d2a9110fe5c84976f6153970684ac35 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
@@ -60,8 +60,10 @@ public class PathfinderGoalWrapped extends PathfinderGoal {
     }
 
     @Override
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a.i();
+    // Tuinity start - reduce garbage on heap
+    public com.tuinity.tuinity.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.a.getGoalTypes();
+        // Tuinity end - reduce garbage on heap
     }
 
     public boolean isRunning() { return this.g(); } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 4240ca81cb6debecc54dcf9a550e9d916dfa8f9f..69fd3cc8ec4680709f26bbe7dd9942d79173b401 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -443,8 +443,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition PATH_TYPE_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); // Tuinity - this shows to be a high allocator
+
     protected static PathType c(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition = PATH_TYPE_BLOCKPOSITION.setValues(i, j, k); // Tuinity - this shows to be a high allocator
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 9f8818c2d4ca0064ab098cc6e0de170dab90b166..d822e6c86c75c618deccdce982ace58eaf4fcf13 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -194,7 +194,7 @@ public class PlayerChunk {
     }
 
     public void a(int i, int j, int k) {
-        Chunk chunk = this.getChunk();
+        Chunk chunk = this.getFullReadyChunk(); // Tuinity - per player view distance - allow block updates in non-ticking chunks
 
         if (chunk != null) {
             this.r |= 1 << (j >> 4);
@@ -214,7 +214,7 @@ public class PlayerChunk {
     }
 
     public void a(EnumSkyBlock enumskyblock, int i) {
-        Chunk chunk = this.getChunk();
+        Chunk chunk = this.getFullReadyChunk(); // Tuinity - per player view distance - allow block updates in non-ticking chunks
 
         if (chunk != null) {
             chunk.setNeedsSaving(true);
@@ -304,9 +304,57 @@ public class PlayerChunk {
     }
 
     private void a(Packet<?> packet, boolean flag) {
-        this.players.a(this.location, flag).forEach((entityplayer) -> {
-            entityplayer.playerConnection.sendPacket(packet);
-        });
+        // Tuinity start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        PlayerChunkMap chunkMap = ((PlayerChunkMap)this.players);
+        com.tuinity.tuinity.util.map.PlayerAreaMap viewDistanceMap = chunkMap.playerViewDistanceBroadcastMap;
+        com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = viewDistanceMap.getObjectsInRange(this.location);
+        if (players == null) {
+            return;
+        }
+
+        long coordinate = com.tuinity.tuinity.util.Util.getCoordinateKey(this.location);
+
+        if (flag) { // flag -> border only
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                if (!player.loadedChunks.contains(coordinate)) {
+                    continue;
+                }
+
+                int viewDistance = viewDistanceMap.getLastViewDistance(player);
+                long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                int distX = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateX(lastPosition) - this.location.x);
+                int distZ = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateZ(lastPosition) - this.location.z);
+
+                if (Math.max(distX, distZ) == viewDistance) {
+                    player.playerConnection.sendPacket(packet);
+                }
+            }
+        } else {
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                if (!player.loadedChunks.contains(coordinate)) {
+                    continue;
+                }
+                player.playerConnection.sendPacket(packet);
+            }
+        }
+
+        return;
+        // Tuinity end - per player view distance
     }
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(ChunkStatus chunkstatus, PlayerChunkMap playerchunkmap) {
@@ -505,8 +553,19 @@ public class PlayerChunk {
                     PlayerChunk.this.isEntityTickingReady = true;
 
 
+                    // Tuinity start - stop throwing garbage on the heap
+                    ChunkProviderServer chunkProvider = PlayerChunk.this.chunkMap.world.getChunkProvider();
+                    if (chunkProvider.isTickingChunks) {
+                        chunkProvider.pendingEntityTickingChunkChanges.put(entityTickingChunk, true);
+                    } else {
+                        chunkProvider.entityTickingChunks.add(entityTickingChunk);
+                    }
+                    // Tuinity end - stop throwing garbage on the heap
 
 
+                    // Tuinity start - per player view distance implementation
+                    PlayerChunk.this.chunkMap.getChunkMapDistanceManager().playerTickViewDistanceHandler.onChunkLoad(this.location.x, this.location.z);
+                    // Tuinity end - per player view distance implementation
                 }
             });
             // Paper end
@@ -515,6 +574,18 @@ public class PlayerChunk {
 
         if (flag6 && !flag7) {
             this.entityTickingFuture.complete(PlayerChunk.UNLOADED_CHUNK); this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
+
+            // Tuinity start - stop throwing garbage on the heap
+            ChunkProviderServer chunkProvider = PlayerChunk.this.chunkMap.world.getChunkProvider();
+            Chunk chunk = this.getFullChunkIfCached();
+            if (chunk != null) {
+                if (chunkProvider.isTickingChunks) {
+                    chunkProvider.pendingEntityTickingChunkChanges.put(chunk, false);
+                } else {
+                    chunkProvider.entityTickingChunks.remove(chunk);
+                }
+            }
+            // Tuinity end - stop throwing garbage on the heap
             this.entityTickingFuture = PlayerChunk.UNLOADED_CHUNK_FUTURE;
         }
 
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index a00adc188d001de8b8a47ccd4582281afb6e7b7c..21bf7d23eba67d6881a6e67be51571000657dfd9 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -55,8 +55,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
-    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap();
-    public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks;
+    //public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap(); // Tuinity - replace chunk map
+    //public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks; // Tuinity - replace chunk map
+    public final com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<PlayerChunk> chunkMap = new com.tuinity.tuinity.chunk.QueuedChangesMapLong2Object<>(8192, 0.7f); // Tuinity - replace chunk map
     private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
     final LongSet loadedChunks; // Paper - private -> package
     public final WorldServer world;
@@ -78,7 +79,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final PlayerMap playerMap;
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> z;
-    int viewDistance; // Paper - private -> package private
+    int viewDistance; public final int getViewDistance() { return this.viewDistance; } // Tuinity - OBFHELPER // Paper - private -> package private
     //public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper // Tuinity - replaced by view distance map
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
@@ -109,6 +110,244 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - distance maps
     private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<EntityPlayer> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
 
+    // Tuinity start - per player view distance
+    int noTickViewDistance;
+    public final int getNoTickViewDistance() {
+        return this.noTickViewDistance;
+    }
+    // we use this map to broadcast chunks to clients
+    // they do not render chunks without having at least neighbours in a 1 chunk radius loaded
+    public final com.tuinity.tuinity.util.map.PlayerAreaMap playerViewDistanceBroadcastMap;
+    public final com.tuinity.tuinity.util.map.PlayerAreaMap playerViewDistanceTickMap;
+    public final com.tuinity.tuinity.util.map.PlayerAreaMap playerViewDistanceNoTickMap;
+
+    final ChunkSendThrottler chunkSendThrottler = new ChunkSendThrottler();
+
+    public void updateViewDistance(EntityPlayer player, int viewDistance, int noTickViewDistance) {
+        player.viewDistance = viewDistance;
+        player.noTickViewDistance = noTickViewDistance;
+
+        int chunkX = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locX());
+        int chunkZ = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locZ());
+
+        int effectiveViewDistance = viewDistance == -1 ? this.viewDistance : viewDistance;
+        int effectiveNoTickViewDistance = Math.max(effectiveViewDistance, noTickViewDistance == -1 ? this.noTickViewDistance : noTickViewDistance);
+
+        player.playerConnection.sendPacket(new PacketPlayOutViewDistance(effectiveNoTickViewDistance));
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+            this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk neighbours // add an extra one for antixray
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need chunk neighbours
+        player.needsChunkCenterUpdate = false;
+    }
+
+    final class ChunkSendThrottler {
+
+        static final int ALREADY_QUEUED = 0;
+        static final int QUEUED = 1;
+        static final int FAILED = 2;
+
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap lastLoadedRadiusByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+
+        {
+            this.lastLoadedRadiusByPlayer.defaultReturnValue(-1);
+        }
+
+        protected final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkPositionByPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+
+        {
+            this.lastChunkPositionByPlayer.defaultReturnValue(Long.MIN_VALUE);
+        }
+
+        protected final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap chunkSendCountPerPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+
+        protected final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkSendStartTimePerPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+
+        protected final java.util.List<EntityPlayer> players = new java.util.ArrayList<>(256);
+
+        protected final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<Packet[]> cachedChunkPackets = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>();
+
+        void addPlayer(EntityPlayer player) {
+            this.players.add(player);
+        }
+
+        void removePlayer(EntityPlayer player) {
+            this.players.remove(player);
+            this.lastLoadedRadiusByPlayer.remove(player.getId());
+            this.chunkSendCountPerPlayer.remove(player.getId());
+            this.lastChunkPositionByPlayer.remove(player.getId());
+            player.loadedChunks.clear();
+        }
+
+        int trySendChunk(int chunkX, int chunkZ, EntityPlayer player) {
+            long coordinate = com.tuinity.tuinity.util.Util.getCoordinateKey(chunkX, chunkZ);
+            PlayerChunk playerChunk = PlayerChunkMap.this.chunkMap.getUpdating(coordinate);
+
+            if (playerChunk == null) {
+                return FAILED;
+            }
+            Chunk chunk = playerChunk.getFullReadyChunk();
+            if (chunk == null || !chunk.areNeighboursLoaded(1)) {
+                return FAILED;
+            }
+
+            if (!player.loadedChunks.add(coordinate)) {
+                return ALREADY_QUEUED;
+            }
+
+            Packet[] chunkPackets = this.cachedChunkPackets.computeIfAbsent(coordinate, (long keyInMap) -> new Packet[2]);
+            PlayerChunkMap.this.sendChunk(player, chunkPackets, chunk);
+
+            return QUEUED;
+        }
+
+        void tick() {
+            int maxChunkSends = com.tuinity.tuinity.config.TuinityConfig.maxChunkSendsPerPlayerChoice[MinecraftServer.currentTick % com.tuinity.tuinity.config.TuinityConfig.maxChunkSendsPerPlayerChoice.length];
+            for (EntityPlayer player : this.players) {
+                int playerId = player.getId();
+                int lastLoadedRadius = this.lastLoadedRadiusByPlayer.get(playerId);
+                long lastChunkPos = this.lastChunkPositionByPlayer.get(playerId);
+                long currentChunkPos = PlayerChunkMap.this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
+
+                if (currentChunkPos == Long.MIN_VALUE) {
+                    // not tracking for whatever reason...
+                    continue;
+                }
+
+                int newX = com.tuinity.tuinity.util.Util.getCoordinateX(currentChunkPos);
+                int newZ = com.tuinity.tuinity.util.Util.getCoordinateZ(currentChunkPos);
+
+                // handle movement
+                if (currentChunkPos != lastChunkPos) {
+                    this.lastChunkPositionByPlayer.put(playerId, currentChunkPos);
+                    if (lastChunkPos != Long.MIN_VALUE) {
+                        int oldX = com.tuinity.tuinity.util.Util.getCoordinateX(lastChunkPos);
+                        int oldZ = com.tuinity.tuinity.util.Util.getCoordinateZ(lastChunkPos);
+
+                        int radiusDiff = Math.max(Math.abs(newX - oldX), Math.abs(newZ - oldZ));
+                        lastLoadedRadius = Math.max(-1, lastLoadedRadius - radiusDiff);
+                        this.lastLoadedRadiusByPlayer.put(playerId, lastLoadedRadius);
+                    }
+                }
+
+                int radius = lastLoadedRadius + 1;
+                int viewDistance = PlayerChunkMap.this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+
+                if (radius > viewDistance) {
+                    // distance map will unload our chunks
+                    this.lastLoadedRadiusByPlayer.put(playerId, viewDistance);
+                    continue;
+                }
+
+                int totalChunkSends = 0;
+
+                if (totalChunkSends >= maxChunkSends) {
+                    continue;
+                }
+
+                radius_loop:
+                for (; radius <= viewDistance; ++radius) {
+                    for (int offset = 0; offset <= radius; ++offset) {
+                        // try to load the chunks closest to the player by distance
+                        // so instead of going left->right on the x axis, we start at the center of the view distance square
+                        // and go left and right at the same time
+
+                        // try top 2 chunks
+                        // top left
+                        int attempt = 0;
+                        if ((attempt = this.trySendChunk(newX - offset, newZ + radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // top right
+                        if ((attempt = this.trySendChunk(newX + offset, newZ + radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try bottom 2 chunks
+
+                        // bottom left
+                        if ((attempt = this.trySendChunk(newX - offset, newZ - radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // bottom right
+                        if ((attempt = this.trySendChunk(newX + offset, newZ - radius, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try left 2 chunks
+
+                        // left down
+                        if ((attempt = this.trySendChunk(newX - radius, newZ - offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // left up
+                        if ((attempt = this.trySendChunk(newX - radius, newZ + offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // try right 2 chunks
+
+                        // right down
+                        if ((attempt = this.trySendChunk(newX + radius, newZ - offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+
+                        // right up
+                        if ((attempt = this.trySendChunk(newX + radius, newZ + offset, player)) == QUEUED) {
+                            if (++totalChunkSends >= maxChunkSends) {
+                                break radius_loop;
+                            }
+                        } else if (attempt == FAILED) {
+                            break radius_loop;
+                        }
+                    }
+                }
+                int newLoadedRadius = radius - 1;
+                if (newLoadedRadius != lastLoadedRadius) {
+                    this.lastLoadedRadiusByPlayer.put(playerId, newLoadedRadius);
+                }
+            }
+            this.cachedChunkPackets.clear();
+        }
+    }
+
+    // Tuinity end - per player view distance
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         this.updateMaps(player);
 
@@ -140,10 +379,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     void addPlayerToDistanceMapsTuinity(EntityPlayer player) {
         this.updateMapsTuinity(player);
+
+        // Tuinity start - per player view distance
+        this.getChunkMapDistanceManager().playerTickViewDistanceHandler.addPlayer(player);
+        this.chunkSendThrottler.addPlayer(player);
+        // Tuinity end - per player view distance
     }
 
     void removePlayerFromDistanceMapsTuinity(EntityPlayer player) {
         this.playerViewDistanceMap.remove(player);
+        // Tuinity start - per player view distance
+        this.playerViewDistanceBroadcastMap.remove(player);
+        this.playerViewDistanceTickMap.remove(player);
+        this.playerViewDistanceNoTickMap.remove(player);
+        this.getChunkMapDistanceManager().playerTickViewDistanceHandler.removePlayer(player);
+        this.chunkSendThrottler.removePlayer(player);
+        // Tuinity end - per player view distance
     }
 
     void updateDistanceMapsTuinity(EntityPlayer player) {
@@ -154,13 +405,26 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int chunkX = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locX());
         int chunkZ = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locZ());
 
-        this.playerViewDistanceMap.update(player, chunkX, chunkZ, this.viewDistance);
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, player.getEffectiveViewDistance(this)); // Tuinity - per player view distance
+
+        // Tuinity start - per player view distance
+        int effectiveViewDistance = player.getEffectiveViewDistance(this);
+        int effectiveNoTickViewDistance = Math.max(effectiveViewDistance, player.getEffectiveNoTickViewDistance(this));
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTickMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+            this.playerViewDistanceNoTickMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 2); // clients need chunk neighbours // add an extra one for antixray
+        }
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveNoTickViewDistance + 1); // clients need chunk neighbours
+        player.needsChunkCenterUpdate = false;
+        // Tuinity end - per player view distance
     }
     // Tuinity end
 
     public PlayerChunkMap(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator<?> chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i) {
         super(new File(worldserver.getWorldProvider().getDimensionManager().a(file), "region"), datafixer);
-        this.visibleChunks = this.updatingChunks.clone();
+        //this.visibleChunks = this.updatingChunks.clone(); // Tuinity - replace chunk map
         this.pendingUnload = new Long2ObjectLinkedOpenHashMap();
         this.loadedChunks = new LongOpenHashSet();
         this.unloadQueue = new LongOpenHashSet();
@@ -194,6 +458,47 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         com.tuinity.tuinity.util.map.PooledLinkedHashSets<EntityPlayer> sets = this.pooledEntityPlayerSets;
         this.playerViewDistanceMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets);
         // Tuinity end - distance maps
+        // Tuinity start - per player view distance
+        this.setNoTickViewDistance(this.world.tuinityConfig.noTickViewDistance < 0 ? this.viewDistance : this.world.tuinityConfig.noTickViewDistance);
+        this.playerViewDistanceTickMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                null,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState != null) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerTickViewDistanceHandler.playerMoveOutOfRange(rangeX, rangeZ);
+                });
+        this.chunkDistanceManager.playerTickViewDistanceHandler.areaMap = this.playerViewDistanceTickMap;
+        this.playerViewDistanceNoTickMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState.size() != 1) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerMoveInRange(rangeX, rangeZ, currPosX, currPosZ);
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState != null) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerMoveOutOfRange(rangeX, rangeZ, currPosX, currPosZ);
+                });
+        this.playerViewDistanceBroadcastMap = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (player.needsChunkCenterUpdate) {
+                        player.needsChunkCenterUpdate = false;
+                        player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));
+                    }
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, null, true, false); // unloaded, loaded
+                    player.loadedChunks.remove(com.tuinity.tuinity.util.Util.getCoordinateKey(rangeX, rangeZ));
+                });
+        // Tuinity end - per player view distance
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -254,8 +559,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     private static int a(ChunkCoordIntPair chunkcoordintpair, int i, int j) {
-        int k = chunkcoordintpair.x - i;
-        int l = chunkcoordintpair.z - j;
+        // Tuinity start - remove ChunkCoordIntPair allocation
+        return getSquareRadiusDistance(chunkcoordintpair.x, chunkcoordintpair.z, i, j);
+    }
+    private static int getSquareRadiusDistance(int chunkX0, int chunkZ0, int i, int j) {
+        int k = chunkX0 - i;
+        int l = chunkZ0 - j;
+        // Tuinity end
 
         return Math.max(Math.abs(k), Math.abs(l));
     }
@@ -266,12 +576,17 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Nullable
     protected PlayerChunk getUpdatingChunk(long i) {
-        return (PlayerChunk) this.updatingChunks.get(i);
+        return (PlayerChunk) this.chunkMap.getUpdating(i); // Tuinity - replace chunk map
     }
 
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
-        return (PlayerChunk) this.visibleChunks.get(i);
+        // Tuinity start - replace chunk map
+        if (MinecraftServer.getServer().serverThread == Thread.currentThread()) {
+            return this.chunkMap.getVisible(i);
+        }
+        return (PlayerChunk) this.chunkMap.getVisibleAsync(i);
+        // Tuinity end - replace chunk map
     }
 
     protected IntSupplier c(long i) {
@@ -373,7 +688,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     playerchunk = new PlayerChunk(new ChunkCoordIntPair(i), j, this.lightEngine, this.p, this);
                 }
 
-                this.updatingChunks.put(i, playerchunk);
+                this.chunkMap.queueUpdate(i, playerchunk); // Tuinity - replace chunk map
                 this.updatingChunksModified = true;
             }
 
@@ -453,7 +768,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void save(boolean flag) {
         if (flag) {
-            List<PlayerChunk> list = (List) this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList());
+            List<PlayerChunk> list = (List) this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList()); // Tuinity - replace chunk map
             MutableBoolean mutableboolean = new MutableBoolean();
 
             do {
@@ -481,7 +796,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 //            this.i(); // Paper - nuke IOWorker
             PlayerChunkMap.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", this.w.getName());
         } else {
-            this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> {
+            this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> { // Tuinity - replace chunk map
                 IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
 
                 if (ichunkaccess instanceof ProtoChunkExtension || ichunkaccess instanceof Chunk) {
@@ -524,7 +839,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         while (longiterator.hasNext()) { // Spigot
             long j = longiterator.nextLong();
             longiterator.remove(); // Spigot
-            PlayerChunk playerchunk = (PlayerChunk) this.updatingChunks.remove(j);
+            PlayerChunk playerchunk = (PlayerChunk) this.chunkMap.queueRemove(j); // Tuinity - replace chunk map
 
             if (playerchunk != null) {
                 this.pendingUnload.put(j, playerchunk);
@@ -652,7 +967,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         if (!this.updatingChunksModified) {
             return false;
         } else {
-            this.visibleChunks = this.updatingChunks.clone();
+            this.chunkMap.performUpdates(); // Tuinity - replace chunk map
             this.updatingChunksModified = false;
             return true;
         }
@@ -945,11 +1260,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         completablefuture1.thenAcceptAsync((either) -> {
             either.mapLeft((chunk) -> {
                 this.u.getAndIncrement();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.a(entityplayer, apacket, chunk);
-                });
+                // Tuinity - per player view distance - moved to full chunk load, instead of ticking load
                 return Either.left(chunk);
             });
         }, (runnable) -> {
@@ -1053,58 +1364,70 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         } // Paper
     }
 
-    protected void setViewDistance(int i) {
-        int j = MathHelper.clamp(i + 1, 3, 33);
+    public void setViewDistance(int i) { // Tuinity - make public
+        int j = MathHelper.clamp(i + 1, 3, 33) - 1; // Tuinity - we correctly handle view distance, no need to add 1
 
         if (j != this.viewDistance) {
             int k = this.viewDistance;
 
             this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
-
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
+            this.chunkDistanceManager.setGlobalViewDistance(this.viewDistance, this); // Tuinity - per player view distance
+            // Tuinity start - view distance map handles this
+            if (this.world != null && this.world.players != null) { // ... called inside constructor, where these may not be initialized
+                for (EntityPlayer player : this.world.players) {
+                    this.updateViewDistance(player, player.getRawViewDistance(), player.getRawNoTickViewDistance());
+                }
+            }
+            // Tuinity end - view distance map handles this
+        }
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
+    }
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+    // Tuinity start - no ticket view distance
+    public void setNoTickViewDistance(int noTickViewDistance) {
+        // modeled after the above
+        noTickViewDistance = MathHelper.clamp(noTickViewDistance, 2, 32);
+        if (this.noTickViewDistance != noTickViewDistance) {
+            this.noTickViewDistance = noTickViewDistance;
+            if (this.world != null && this.world.players != null) { // ... called inside constructor, where these may not be initialized
+                for (EntityPlayer player : this.world.players) {
+                    this.updateViewDistance(player, player.getRawViewDistance(), player.getRawNoTickViewDistance());
+                }
             }
         }
-
     }
+    // Tuinity end
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        // Tuinity start - remove ChunkCoordIntPair allocation, use two ints instead of ChunkCoordIntPair
+        this.sendChunk(entityplayer, chunkcoordintpair.x, chunkcoordintpair.z, apacket, flag, flag1);
+    }
+    protected void sendChunk(EntityPlayer entityplayer, int chunkX, int chunkZ, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        // Tuinity end
         if (entityplayer.world == this.world) {
             if (flag1 && !flag) {
-                PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
+                PlayerChunk playerchunk = this.getVisibleChunk(ChunkCoordIntPair.pair(chunkX, chunkZ)); // Tuinity - remove ChunkCoordIntPair allocation
 
                 if (playerchunk != null) {
-                    Chunk chunk = playerchunk.getChunk();
+                    Chunk chunk = playerchunk.getFullReadyChunk(); // Tuinity - per player view distance
 
                     if (chunk != null) {
                         this.a(entityplayer, apacket, chunk);
                     }
 
-                    PacketDebug.a(this.world, chunkcoordintpair);
+                    //PacketDebug.a(this.world, chunkcoordintpair); // Tuinity - remove ChunkCoordIntPair allocation (this function is a no-op)
                 }
             }
 
             if (!flag1 && flag) {
-                entityplayer.a(chunkcoordintpair);
+                entityplayer.sendChunkUnload(chunkX, chunkZ); // Tuinity - remove ChunkCoordIntPair allocation
             }
 
         }
     }
 
     public int d() {
-        return this.visibleChunks.size();
+        return this.chunkMap.getVisibleSizeAsync(); // Tuinity - replace chunk map
     }
 
     protected PlayerChunkMap.a e() {
@@ -1112,12 +1435,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected Iterable<PlayerChunk> f() {
-        return Iterables.unmodifiableIterable(this.visibleChunks.values());
+        return Iterables.unmodifiableIterable(this.chunkMap.getUpdatingValuesCopy()); // Tuinity - replace chunk map
     }
 
     void a(Writer writer) throws IOException {
         CSVWriter csvwriter = CSVWriter.a().a("x").a("z").a("level").a("in_memory").a("status").a("full_status").a("accessible_ready").a("ticking_ready").a("entity_ticking_ready").a("ticket").a("spawning").a("entity_count").a("block_entity_count").a(writer);
-        ObjectBidirectionalIterator objectbidirectionaliterator = this.visibleChunks.long2ObjectEntrySet().iterator();
+        ObjectBidirectionalIterator objectbidirectionaliterator = this.chunkMap.getVisibleMap().long2ObjectEntrySet().iterator(); // Tuinity - replace chunk map
 
         while (objectbidirectionaliterator.hasNext()) {
             Entry<PlayerChunk> entry = (Entry) objectbidirectionaliterator.next();
@@ -1332,6 +1655,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         });
     }
 
+    private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } // Tuinity - OBFHELPER
     private boolean b(EntityPlayer entityplayer) {
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
@@ -1357,13 +1681,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
-
-                this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
-            }
+        // Tuinity start - view distance map handles this
+        if (flag) {
+            this.updateMaps(entityplayer);
         }
+        // Tuinity end - view distance map handles this
 
     }
 
@@ -1371,7 +1693,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         SectionPosition sectionposition = SectionPosition.a((Entity) entityplayer);
 
         entityplayer.a(sectionposition);
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutViewCentre(sectionposition.a(), sectionposition.c()));
+        //entityplayer.playerConnection.sendPacket(new PacketPlayOutViewCentre(sectionposition.a(), sectionposition.c())); // Tuinity - distance map handles this now
         return sectionposition;
     }
 
@@ -1426,56 +1748,53 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        this.updateMaps(entityplayer); // Paper - distance maps
+        this.updateDistanceMapsTuinity(entityplayer); // Tuinity - distance maps
+    }
+
+    @Override
+    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        // Tuinity start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<EntityPlayer> players = new ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (flag) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
 
-            for (int k2 = k1; k2 <= i2; ++k2) {
-                for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+                int distX = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateX(lastPosition) - chunkcoordintpair.x);
+                int distZ = Math.abs(com.tuinity.tuinity.util.Util.getCoordinateZ(lastPosition) - chunkcoordintpair.z);
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
                 }
             }
         } else {
-            ChunkCoordIntPair chunkcoordintpair1;
-            boolean flag5;
-            boolean flag6;
-
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
-                    flag5 = true;
-                    flag6 = false;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
-                }
-            }
-
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
-                    flag5 = false;
-                    flag6 = true;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
                 }
+                EntityPlayer player = (EntityPlayer)temp;
+                players.add(player);
             }
         }
 
-        this.updateMaps(entityplayer); // Paper - distance maps
-        this.updateDistanceMapsTuinity(entityplayer); // Tuinity - distance maps
-    }
-
-    @Override
-    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
-        return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
-            int i = b(chunkcoordintpair, entityplayer, true);
-
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
-        });
+        return players.stream();
     }
 
     protected void addEntity(Entity entity) {
@@ -1596,6 +1915,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     }
 
+    final void sendChunk(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) { this.a(entityplayer, apacket, chunk); } // Tuinity - OBFHELPER
     private void a(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) {
         if (apacket[0] == null) {
             apacket[0] = new PacketPlayOutMapChunk(chunk, 65535, true); // Paper - Anti-Xray
@@ -1726,10 +2046,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         public void updatePlayer(EntityPlayer entityplayer) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
-                Vec3D vec3d = entityplayer.getPositionVector().d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
-                int i = Math.min(this.b(), (PlayerChunkMap.this.viewDistance - 1) * 16);
-                boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
-
+                // Tuinity start - remove allocation of Vec3d here
+                double vec3d_dx = entityplayer.locX() - this.tracker.locX();
+                double vec3d_dy = entityplayer.locY() - this.tracker.locY();
+                double vec3d_dz = entityplayer.locZ() - this.tracker.locZ();
+                // Tuinity end - remove allocation of Vec3d here
+                int i = Math.min(this.b(), (entityplayer.getEffectiveViewDistance(PlayerChunkMap.this)) * 16);  // Tuinity - per player view distance
+                boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.tracker.a(entityplayer); // Tuinity start - remove allocation of Vec3d here
                 if (flag) {
                     boolean flag1 = this.tracker.attachedToPlayer;
 
@@ -1738,7 +2061,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
+                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= (1 + PlayerChunkMap.this.playerViewDistanceTickMap.getLastViewDistance(entityplayer)) && entityplayer.loadedChunks.contains(com.tuinity.tuinity.util.Util.getCoordinateKey(this.tracker)); // Tuinity - per player view distance
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerInventory.java b/src/main/java/net/minecraft/server/PlayerInventory.java
index d103cfaace4f42aaad677103f4eef578490699da..1b8cb3fc61e83d52625d221495173c301b0ce52a 100644
--- a/src/main/java/net/minecraft/server/PlayerInventory.java
+++ b/src/main/java/net/minecraft/server/PlayerInventory.java
@@ -559,8 +559,10 @@ public class PlayerInventory implements IInventory, INamableTileEntity {
 
         NonNullList nonnulllist;
 
-        for (Iterator iterator = this.f.iterator(); iterator.hasNext(); i -= nonnulllist.size()) {
-            nonnulllist = (NonNullList) iterator.next();
+        // Tuinity start - reduce iterator creation
+        for (int index = 0, len = this.f.size(); index < len; ++index, i -= nonnulllist.size()) {
+            nonnulllist = this.f.get(index);
+            // Tuinity end - reduce iterator creation
             if (i < nonnulllist.size()) {
                 list = nonnulllist;
                 break;
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 7b79ee4fe5893d0c8c5825776c3c09ca8553abc8..253ee52eb51cfc95a671cad6e188bc07d4a000c1 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -156,7 +156,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, flag1, !flag));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), Math.max(entityplayer.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap), entityplayer.getEffectiveNoTickViewDistance(worldserver.getChunkProvider().playerChunkMap)), flag1, !flag)); // Tuinity - per player view distance
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -700,7 +700,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(),  WorldData.c(worldserver.getWorldData().getSeed()), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(Math.max(entityplayer1.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap), entityplayer1.getEffectiveNoTickViewDistance(worldserver.getChunkProvider().playerChunkMap)))); // Spigot // Tuinity - per player view distance
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX(), entityplayer1.locY(), entityplayer1.locZ(), entityplayer1.yaw, entityplayer1.pitch));
@@ -1178,7 +1178,7 @@ public abstract class PlayerList {
 
     public void a(int i) {
         this.viewDistance = i;
-        this.sendAll(new PacketPlayOutViewDistance(i));
+        //this.sendAll(new PacketPlayOutViewDistance(i)); // Tuinity - move into setViewDistance
         Iterator iterator = this.server.getWorlds().iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/ProtoChunk.java b/src/main/java/net/minecraft/server/ProtoChunk.java
index f376e210687fb30fbe8e093c397b710d3bd07ecc..5a883aac14052f6637acbf4cf96236936fee98c3 100644
--- a/src/main/java/net/minecraft/server/ProtoChunk.java
+++ b/src/main/java/net/minecraft/server/ProtoChunk.java
@@ -180,14 +180,11 @@ public class ProtoChunk implements IChunkAccess {
                     lightengine.a(blockposition);
                 }
 
-                EnumSet<HeightMap.Type> enumset = this.getChunkStatus().h();
+                HeightMap.Type[] enumset = this.getChunkStatus().heightMaps; // Tuinity - reduce iterator creation
                 EnumSet<HeightMap.Type> enumset1 = null;
-                Iterator iterator = enumset.iterator();
+                // Tuinity - reduce iterator creation
 
-                HeightMap.Type heightmap_type;
-
-                while (iterator.hasNext()) {
-                    heightmap_type = (HeightMap.Type) iterator.next();
+                for (HeightMap.Type heightmap_type : enumset) { // Tuinity - reduce iterator creation
                     HeightMap heightmap = (HeightMap) this.f.get(heightmap_type);
 
                     if (heightmap == null) {
@@ -203,10 +200,9 @@ public class ProtoChunk implements IChunkAccess {
                     HeightMap.a(this, enumset1);
                 }
 
-                iterator = enumset.iterator();
-
-                while (iterator.hasNext()) {
-                    heightmap_type = (HeightMap.Type) iterator.next();
+                // Tuinity start - reduce iterator creation
+                for (HeightMap.Type heightmap_type : enumset) {
+                    // Tuinity end
                     ((HeightMap) this.f.get(heightmap_type)).a(i & 15, j, k & 15, iblockdata);
                 }
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeArray.java b/src/main/java/net/minecraft/server/VoxelShapeArray.java
index caf297fe977942ca68fdb963d97dd9fc0f78d883..3161e3b9772e911991a5106615afdd10858b8452 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeArray.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeArray.java
@@ -11,7 +11,7 @@ public final class VoxelShapeArray extends VoxelShape {
     private final DoubleList d;
 
     protected VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, double[] adouble, double[] adouble1, double[] adouble2) {
-        this(voxelshapediscrete, (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble, voxelshapediscrete.b() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble1, voxelshapediscrete.c() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble2, voxelshapediscrete.d() + 1)));
+        this(voxelshapediscrete, com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList.getList(adouble, voxelshapediscrete.b() + 1), com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList.getList(adouble1, voxelshapediscrete.c() + 1), com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList.getList(adouble2, voxelshapediscrete.d() + 1)); // Tuinity - remove iterator allocation
     }
 
     VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, DoubleList doublelist, DoubleList doublelist1, DoubleList doublelist2) {
diff --git a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
index 9e09671dc24cfcd3bfe872cacdeb0a5d7e83c112..b69a1ed46a0a90a22fa1223613a43aac8ec4072a 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
@@ -2,7 +2,7 @@ package net.minecraft.server;
 
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
-public class VoxelShapeCubePoint extends AbstractDoubleList {
+public class VoxelShapeCubePoint extends com.tuinity.tuinity.util.fastutil.ExtendedAbstractDoubleList { // Tuinity - remove iterator allocation
 
     private final int a;
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
index 71d2ae2a9c5a05351241b5a313e66ca15b0624ef..9129eaa6422f695e1408e4227420f4c71438d05a 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
@@ -18,7 +18,7 @@ public final class VoxelShapeMergerList implements VoxelShapeMerger {
         int l = doublelist1.size();
         int i1 = k + l;
 
-        this.a = new DoubleArrayList(i1);
+        this.a = new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(i1); // Tuinity - remove iterator creation
         this.b = new IntArrayList(i1);
         this.c = new IntArrayList(i1);
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index 08c83c62dfe875600162a46a0ca4b835b0bfe199..d5da9f582558356c128c9543aac5dac2325e6167 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -19,7 +19,7 @@ public final class VoxelShapes {
         return new VoxelShapeCube(voxelshapebitset);
     });
     public static final VoxelShape a = create(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
-    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}));
+    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new com.tuinity.tuinity.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D})); // Tuinity - remove iterator allocation
 
     public static VoxelShape a() {
         return VoxelShapes.c;
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 58845d19c9853cc36fd33126b9bc9e088041af34..abfabc5029708a02f92bdc9c1bf89f74aec3b9aa 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -443,8 +443,13 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
                 this.b(blockposition, iblockdata1, iblockdata2);
             }
 
-            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+            if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || (chunk.getState() != null && chunk.getState().isAtLeast(PlayerChunk.State.TICKING)))) { // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement // Tuinity - diff on change, see below
                 this.notify(blockposition, iblockdata1, iblockdata, i);
+                // Tuinity start - per player view distance - allow block updates for non-ticking chunks in player view distance
+                // if copied from above
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((WorldServer)this).getChunkProvider().playerChunkMap.playerViewDistanceBroadcastMap.getObjectsInRange(com.tuinity.tuinity.util.Util.getCoordinateKey(blockposition)) != null)) {
+                ((WorldServer)this).getChunkProvider().flagDirty(blockposition);
+                // Tuinity end - per player view distance
             }
 
             if (!this.isClientSide && (i & 1) != 0) {
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index fa19835106f96624f7905834b154ef9ba7302b1c..51b3c9d561152acb1f4b5adf72e9939a5f32675a 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -55,7 +55,7 @@ public class WorldServer extends World {
 
     private static final Logger LOGGER = LogManager.getLogger();
     private final List<Entity> globalEntityList = Lists.newArrayList();
-    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
+    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); // Tuinity - diff on change, we expect Int2ObjectLinkedOpenHashMap
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
@@ -465,7 +465,7 @@ public class WorldServer extends World {
 
             gameprofilerfiller.exitEnter("regular");
             this.tickingEntities = true;
-            ObjectIterator objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+            ObjectIterator objectiterator = ((Int2ObjectLinkedOpenHashMap)this.entitiesById).int2ObjectEntrySet().fastIterator(); // Tuinity - use fast iterator to reduce entry creation
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 1a5ee3410305fa6ed23266f9b460121188df1879..e175da85f6008102de36b6bee6d98f6347c809e6 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.tuinity.tuinity.util.TickThread;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import java.io.File;
 import java.io.IOException;
@@ -287,9 +288,9 @@ public class CraftWorld implements World {
     }
     public int getTileEntityCount() {
         // We don't use the full world tile entity list, so we must iterate chunks
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
+        Iterable<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); // Tuinity - replace chunk map
         int size = 0;
-        for (net.minecraft.server.PlayerChunk playerchunk : chunks.values()) {
+        for (net.minecraft.server.PlayerChunk playerchunk : chunks) { // Tuinity - replace chunk map
             net.minecraft.server.Chunk chunk = playerchunk.getChunk();
             if (chunk == null) {
                 continue;
@@ -304,7 +305,7 @@ public class CraftWorld implements World {
     public int getChunkCount() {
         int ret = 0;
 
-        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.visibleChunks.values()) {
+        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues()) { // Tuinity - replace chunk map
             if (chunkHolder.getChunk() != null) {
                 ++ret;
             }
@@ -428,8 +429,8 @@ public class CraftWorld implements World {
 
     @Override
     public Chunk[] getLoadedChunks() {
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
-        return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
+        Collection<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); // Tuinity - replace chunk map
+        return chunks.stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new); // Tuinity - replace chunk map
     }
 
     @Override
@@ -2454,10 +2455,43 @@ public class CraftWorld implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return world.spigotConfig.viewDistance;
+        return getHandle().getChunkProvider().playerChunkMap.getViewDistance(); // Tuinity start - per player view distance
     }
     // Spigot end
 
+    // Tuinity start - per player view distance
+
+
+    @Override
+    public void setViewDistance(int viewDistance) {
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if (viewDistance < 2 || viewDistance > 32) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        net.minecraft.server.PlayerChunkMap chunkMap = getHandle().getChunkProvider().playerChunkMap;
+        if (viewDistance != chunkMap.getViewDistance()) {
+            chunkMap.setViewDistance(viewDistance);
+        }
+    }
+
+    @Override
+    public int getNoTickViewDistance() {
+        return getHandle().getChunkProvider().playerChunkMap.getNoTickViewDistance();
+    }
+
+    @Override
+    public void setNoTickViewDistance(int viewDistance) {
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if (viewDistance < 2 || viewDistance > 32) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        net.minecraft.server.PlayerChunkMap chunkMap = getHandle().getChunkProvider().playerChunkMap;
+        if (viewDistance != chunkMap.getNoTickViewDistance()) {
+            chunkMap.setNoTickViewDistance(viewDistance);
+        }
+    }
+    // Tuinity end - per player view distance
+
     // Spigot start
     private final Spigot spigot = new Spigot()
     {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 60f62f19cbc2c115fe7bf399877b774e6d72bdb5..651ff6647398747199cbfcc5f49b8ccd707609af 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.entity;
 
+import com.tuinity.tuinity.util.TickThread; // Tuinity
 import com.destroystokyo.paper.Title;
 import com.destroystokyo.paper.profile.CraftPlayerProfile;
 import com.destroystokyo.paper.profile.PlayerProfile;
@@ -1997,13 +1998,39 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().getEffectiveViewDistance(); // Tuinity - per player view distance
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        // Tuinity start - per player view distance
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        if (viewDistance != getHandle().getRawViewDistance()) {
+            ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.updateViewDistance(getHandle(), viewDistance, getHandle().getRawNoTickViewDistance());
+        }
+        // Tuinity end - per player view distance
+    }
+
+    // Tuinity start - per player view distance
+    @Override
+    public int getNoTickViewDistance() {
+        return getHandle().getEffectiveNoTickViewDistance();
+    }
+
+    @Override
+    public void setNoTickViewDistance(int viewDistance) {
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        if (viewDistance != getHandle().getRawNoTickViewDistance()) {
+            ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.updateViewDistance(getHandle(), getHandle().getRawViewDistance(), viewDistance);
+        }
     }
+    // Tuinity end - per player view distance
     // Paper end
 
     // Spigot start
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 6e165a16498c9f84fd00ed3fdc28a1774d9827bc..3fb177f9882ca1d8ad1f6b143d8b377b3f6306aa 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -38,6 +38,7 @@ import net.minecraft.server.EntityInsentient;
 import net.minecraft.server.EntityLlama;
 import net.minecraft.server.EntityWaterAnimal;
 // Paper end
+import net.minecraft.server.WorldServer; // Tuinity
 
 public class ActivationRange
 {
@@ -128,14 +129,15 @@ public class ActivationRange
         final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
         final int waterActivationRange = world.spigotConfig.waterActivationRange; // Paper
 
-        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
-        maxRange = Math.max( maxRange, raiderActivationRange );
-        maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        // Tuinity start - per player view distance
+        int maxRangeTemp = Math.max( monsterActivationRange, animalActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, raiderActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, miscActivationRange );
 
         for ( EntityHuman player : world.getPlayers() )
         {
-
+            final int maxRange = Math.min( ( ( player instanceof net.minecraft.server.EntityPlayer ? ((net.minecraft.server.EntityPlayer)player).getEffectiveViewDistance(((WorldServer)world).getChunkProvider().playerChunkMap) : world.spigotConfig.viewDistance ) << 4 ) - 8, maxRangeTemp );
+            // Tuinity end - per player view distance
             player.activatedTick = MinecraftServer.currentTick;
             maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
