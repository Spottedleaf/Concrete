From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Mon, 7 Oct 2019 04:53:46 -0700
Subject: [PATCH] Use distance map to optimise entity tracker

Add a new config option to enable tracking entities by a chunk range.

diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index c9a3ba4bfb1a4c3b08d752f00e2c125accc1c502..af24eb0bcf20b655446f76c2143e037c4d8f7f63 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -34,6 +34,7 @@ public class WorldTimingsHandler {
     public final Timing tileEntityPending;
     public final Timing tracker1;
     public final Timing tracker2;
+    public final Timing tracker3; // Tuinity - legacy tracker
     public final Timing doTick;
     public final Timing tickEntities;
     public final Timing chunks;
@@ -118,6 +119,7 @@ public class WorldTimingsHandler {
 
         tracker1 = Timings.ofSafe(name + "tracker stage 1");
         tracker2 = Timings.ofSafe(name + "tracker stage 2");
+        tracker3 = Timings.ofSafe(name + "tracker stage 3"); // Tuinity - legacy tracker
         doTick = Timings.ofSafe(name + "doTick");
         tickEntities = Timings.ofSafe(name + "tickEntities");
 
diff --git a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
index e3b209d04633fffcdbda5ef0f200b2a21f26d03d..16bc8161a5b72531cae7f32110b1ee8dad9efe68 100644
--- a/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
+++ b/src/main/java/com/tuinity/tuinity/config/TuinityConfig.java
@@ -1,6 +1,7 @@
 package com.tuinity.tuinity.config;
 
 import ca.spottedleaf.concurrentutil.util.Throw;
+import net.minecraft.server.TicketType;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
@@ -156,6 +157,16 @@ public final class TuinityConfig {
         }
     }
 
+    public static int delayChunkUnloadsBy;
+
+    private static void delayChunkUnloadsBy() {
+        delayChunkUnloadsBy = TuinityConfig.getInt("delay-chunkunloads-by", 10) * 20;
+        if (delayChunkUnloadsBy >= 0) {
+            TicketType.DELAYED_UNLOAD.loadPeriod = delayChunkUnloadsBy;
+        }
+    }
+
+
     public static final class WorldConfig {
 
         public final String worldName;
@@ -279,6 +290,16 @@ public final class TuinityConfig {
         private void noTickViewDistance() {
             this.noTickViewDistance = this.getInt("no-tick-view-distance", -1);
         }
+
+        public boolean useOptimizedTracker;
+
+        private void optimizetracker() {
+            if (TuinityConfig.configVersion < 1) {
+                this.set("optimized-tracker-track-range", null);
+                this.set("optimized-tracker-untrack-range", null);
+            }
+            this.useOptimizedTracker = this.getBoolean("optimized-tracker", true);
+        }
     }
 
 }
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 24ba03ae580858fde7c32c915bb447b97ea229a6..d3c616e72ddddb87e019864b0b90228c96636ebc 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -70,6 +70,7 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     protected abstract int b(long i);
 
+    public final void update(long coordinate, int level, boolean increaseInLevel) { this.b(coordinate, level, increaseInLevel); } // Tuinity - OBFHELPER
     public void b(long i, int j, boolean flag) {
         this.a(ChunkCoordIntPair.a, i, j, flag);
     }
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 223097ec271a25344480d88635fd8b51deca88ff..6826c0369c063b3e7b8867181f1bec260e57234a 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -31,7 +31,7 @@ public abstract class ChunkMapDistance {
     private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2; public static int getPlayerTicketLevel() { return ChunkMapDistance.b; } // Tuinity - OBFHELPER
     private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
     public final Long2ObjectOpenHashMap<ArraySetSorted<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
-    private final ChunkMapDistance.a e = new ChunkMapDistance.a();
+    private final ChunkMapDistance.a e = new ChunkMapDistance.a(); final ChunkMapDistance.a getTicketTracker() { return this.e; } // Tuinity - OBFHELPER
     public static final int MOB_SPAWN_RANGE = 8; //private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Tuinity - no longer used
     //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); // Tuinity - no longer used
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.ArrayDeque<>(); // PAIL pendingChunkUpdates // Paper - use a queue // Tuinity - use a better queue
@@ -105,6 +105,47 @@ public abstract class ChunkMapDistance {
     }
     // Tuinity end
 
+    // Tuinity start - delay chunk unloads
+    private long nextUnloadId; // delay chunk unloads
+    private final Long2ObjectOpenHashMap<Ticket<Long>> delayedChunks = new Long2ObjectOpenHashMap<>();
+    public final void removeTickets(long chunk, TicketType<?> type) {
+        ArraySetSorted<Ticket<?>> tickets = this.tickets.get(chunk);
+        if (tickets == null) {
+            return;
+        }
+        if (type == TicketType.DELAYED_UNLOAD) {
+            this.delayedChunks.remove(chunk);
+        }
+        boolean changed = tickets.removeIf((Ticket<?> ticket) -> {
+            return ticket.getTicketType() == type;
+        });
+        if (changed) {
+            this.getTicketTracker().update(chunk, getLowestTicketLevel(tickets), false);
+        }
+    }
+
+    private final java.util.function.LongFunction<Ticket<Long>> computeFuntion = (long key) -> {
+        Ticket<Long> ret = new Ticket<>(TicketType.DELAYED_UNLOAD, -1, ++ChunkMapDistance.this.nextUnloadId);
+        ret.isCached = true;
+        return ret;
+    };
+
+    private void computeDelayedTicketFor(long chunk, int removedLevel, ArraySetSorted<Ticket<?>> tickets) {
+        int lowestLevel = getLowestTicketLevel(tickets);
+        if (removedLevel > lowestLevel) {
+            return;
+        }
+        final Ticket<Long> ticket = this.delayedChunks.computeIfAbsent(chunk, this.computeFuntion);
+        if (ticket.getTicketLevel() != -1) {
+            // since we modify data used in sorting, we need to remove before
+            tickets.remove(ticket);
+        }
+        ticket.setCreationTick(this.currentTick);
+        ticket.setTicketLevel(removedLevel);
+        tickets.add(ticket); // re-add with new expire time and ticket level
+    }
+    // Tuinity end - delay chunk unloads
+
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
         Mailbox<Runnable> mailbox = Mailbox.a("player ticket throttler", executor1::execute);
@@ -121,12 +162,30 @@ public abstract class ChunkMapDistance {
         ++this.currentTick;
         ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
+        int[] tempLevel = new int[] { PlayerChunkMap.GOLDEN_TICKET + 1 }; // Tuinity - delay chunk unloads
         while (objectiterator.hasNext()) {
             Entry<ArraySetSorted<Ticket<?>>> entry = (Entry) objectiterator.next();
 
             if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
-                return ticket.b(this.currentTick);
+                // Tuinity start - delay chunk unloads
+                boolean ret = ticket.isExpired(this.currentTick);
+                if (com.tuinity.tuinity.config.TuinityConfig.delayChunkUnloadsBy <= 0) {
+                    return ret;
+                }
+                if (ret && ticket.getTicketType() != TicketType.DELAYED_UNLOAD && ticket.getTicketLevel() < tempLevel[0]) {
+                    tempLevel[0] = ticket.getTicketLevel();
+                }
+                if (ticket.getTicketType() == TicketType.DELAYED_UNLOAD && ticket.isCached) {
+                    this.delayedChunks.remove(entry.getLongKey(), ticket); // clean up ticket...
+                }
+                return ret;
+                // Tuinity end - delay chunk unloads
             })) {
+                // Tuinity start - delay chunk unloads
+                if (tempLevel[0] < (PlayerChunkMap.GOLDEN_TICKET + 1)) {
+                    this.computeDelayedTicketFor(entry.getLongKey(), tempLevel[0], entry.getValue());
+                }
+                // Tuinity end - delay chunk unloads
                 this.e.b(entry.getLongKey(), a((ArraySetSorted) entry.getValue()), false);
             }
 
@@ -137,6 +196,7 @@ public abstract class ChunkMapDistance {
 
     }
 
+    private static int getLowestTicketLevel(ArraySetSorted<Ticket<?>> arraysetsorted) { return a(arraysetsorted); } // Tuinity - OBFHELPER
     private static int a(ArraySetSorted<Ticket<?>> arraysetsorted) {
         return !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.b()).b() : PlayerChunkMap.GOLDEN_TICKET + 1;
     }
@@ -221,6 +281,11 @@ public abstract class ChunkMapDistance {
         boolean removed = false; // CraftBukkit
         if (arraysetsorted.remove(ticket)) {
             removed = true; // CraftBukkit
+            // Tuinity start - delay chunk unloads
+            if (com.tuinity.tuinity.config.TuinityConfig.delayChunkUnloadsBy > 0 && ticket.getTicketType() != TicketType.DELAYED_UNLOAD) {
+                this.computeDelayedTicketFor(i, ticket.getTicketLevel(), arraysetsorted);
+            }
+            // Tuinity end - delay chunk unloads
         }
 
         if (arraysetsorted.isEmpty()) {
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 8974c16bf92cae8cfd1ae9cf24c4aecdb0c91a7c..0f36f9fa2bd15a8247082f71b667a5d5eb69b345 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -208,6 +208,117 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     }
     // CraftBukkit end
 
+    // Tuinity start
+    boolean isLegacyTrackingEntity = this instanceof EntityPlayer && (this.getClass() != EntityPlayer.class); // TODO temp, fix citizens...
+
+    com.tuinity.tuinity.util.map.PlayerAreaMap trackingAreaMap;
+    com.tuinity.tuinity.util.map.PlayerAreaMap unTrackingAreaMap;
+
+    final void acquireTrackingMap(PlayerChunkMap chunkMap) {
+        int key = org.spigotmc.TrackingRange.getTrackingRangeType(this).ordinal();
+        this.trackingAreaMap = chunkMap.playerEntityTrackerTrackMaps[key];
+        this.unTrackingAreaMap = chunkMap.playerEntityTrackerUntrackMaps[key];
+    }
+
+    final void releaseTrackingMap(PlayerChunkMap chunkMap) {
+        this.trackingAreaMap = null;
+        this.unTrackingAreaMap = null;
+    }
+
+    public final void setLegacyTrackingEntity(final boolean isLegacyTrackingEntity) {
+        if (this.isLegacyTrackingEntity == isLegacyTrackingEntity) {
+            return;
+        }
+
+        if (this.world == null) {
+            this.isLegacyTrackingEntity = isLegacyTrackingEntity;
+            return;
+        }
+
+        WorldServer world = (WorldServer)this.world;
+        PlayerChunkMap chunkMap = world.getChunkProvider().playerChunkMap;
+
+        if (!chunkMap.optimisedTrackerEnabled) {
+            this.isLegacyTrackingEntity = isLegacyTrackingEntity;
+            return;
+        }
+        com.tuinity.tuinity.util.TickThread.ensureTickThread("Cannot update legacy tracking off of the main thread");
+
+        if (this.isLegacyTrackingEntity) {
+            this.isLegacyTrackingEntity = false;
+            chunkMap.activelyTrackedEntitiesLegacy.remove(this);
+
+            PlayerChunkMap.EntityTracker tracker = this.tracker;
+            if (tracker != null) {
+                com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = this.trackingAreaMap.getObjectsInRange(com.tuinity.tuinity.util.Util.getCoordinateKey(this));
+
+                for (EntityPlayer player : world.getPlayers()) {
+                    tracker.clear(player);
+                    if (inRange != null && inRange.contains(player)) {
+                        this.addToTrackQueue(player);
+                    }
+                }
+            }
+        } else {
+            this.isLegacyTrackingEntity = true;
+            chunkMap.activelyTrackedEntitiesLegacy.add(this);
+
+            PlayerChunkMap.EntityTracker tracker = chunkMap.trackedEntities.get(this.getId());
+            if (tracker != null) {
+                for (EntityPlayer player : world.getPlayers()) {
+                    this.clearTrackingQueues(player);
+                    tracker.clear(player);
+                    tracker.updatePlayer(player);
+                }
+            }
+        }
+    }
+
+    // We queue changes to tracker here because when adding to a chunk we do not know if the entity is in a trackable state
+    public final it.unimi.dsi.fastutil.ints.IntLinkedOpenHashSet trackQueue = new it.unimi.dsi.fastutil.ints.IntLinkedOpenHashSet(8);
+    public final it.unimi.dsi.fastutil.ints.IntLinkedOpenHashSet unTrackQueue = new it.unimi.dsi.fastutil.ints.IntLinkedOpenHashSet(8);
+
+    public final void addToTrackQueue(EntityPlayer player) {
+        if (player == this) {
+            return;
+        }
+        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Adding to track queue from off-main thread");
+        int id = player.getId();
+        this.unTrackQueue.remove(id);
+        this.trackQueue.add(id);
+        ((WorldServer)this.world).trackingUpdateQueue.add(this);
+    }
+
+    public final void addToUntrackQueue(EntityPlayer player) {
+        if (player == this) {
+            return;
+        }
+        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Removing from track queue from off-main thread");
+        int id = player.getId();
+        this.trackQueue.remove(id);
+        // don't queue untrack if we're not tracked
+        if (this.tracker == null || !this.tracker.trackedPlayers.contains(player)) {
+            return;
+        }
+        this.unTrackQueue.add(id);
+        ((WorldServer)this.world).trackingUpdateQueue.add(this);
+    }
+
+    public final void clearTrackingQueues(EntityPlayer player) {
+        if (player == this) {
+            return;
+        }
+        int id = player.getId();
+        this.trackQueue.remove(id);
+        this.unTrackQueue.remove(id);
+        if (this.trackQueue.isEmpty() && this.unTrackQueue.isEmpty()) {
+            ((WorldServer)this.world).trackingUpdateQueue.remove(this);
+        }
+    }
+
+
+    // Tuinity end
+
     public Entity(EntityTypes<?> entitytypes, World world) {
         this.id = Entity.entityCount.incrementAndGet();
         this.passengers = Lists.newArrayList();
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 40d6e8bf7c34d91bbc44d23efc498daa4f61b7e2..0323055c688e3eadf4f2c56b82b20cdd7f365a30 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -18,7 +18,7 @@ import org.bukkit.event.player.PlayerVelocityEvent;
 public class EntityTrackerEntry {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final WorldServer b;
+    private final WorldServer b; private WorldServer getWorld() { return this.b; } // Tuinity - OBFHELPER
     private final Entity tracker;
     private final int d;
     private final boolean e;
@@ -70,6 +70,7 @@ public class EntityTrackerEntry {
         this.r = entity.onGround;
     }
 
+    public final void tick() { this.a(); } // Tuinity - OBFHELPER
     public void a() {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Tracker update"); // Tuinity
         List<Entity> list = this.tracker.getPassengers();
@@ -108,8 +109,8 @@ public class EntityTrackerEntry {
             int j;
 
             if (this.tracker.isPassenger()) {
-                i = MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
-                j = MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
+                i = MathHelper.d(this.tracker.yaw * 256.0F / 360.0F); // Tuinity - diff on change, used in forceStaleMeta
+                j = MathHelper.d(this.tracker.pitch * 256.0F / 360.0F); // Tuinity - diff on change, used in forceStaleMeta
                 boolean flag = Math.abs(i - this.yRot) >= 1 || Math.abs(j - this.xRot) >= 1;
 
                 if (flag) {
@@ -253,11 +254,13 @@ public class EntityTrackerEntry {
 
     }
 
+    public final void onUntrack(EntityPlayer player) { this.a(player); } // Tuinity - OBFHELPER
     public void a(EntityPlayer entityplayer) {
         this.tracker.c(entityplayer);
         entityplayer.c(this.tracker);
     }
 
+    public final void onTrack(EntityPlayer player) { this.b(player); } // Tuinity - OBFHELPER
     public void b(EntityPlayer entityplayer) {
         PlayerConnection playerconnection = entityplayer.playerConnection;
 
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 5e27af90f1fc8f76ce68effd82a5ea66849f1e63..ca4e4cf03c47232d0b9fcd1610b63ed9cbcca7e8 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -146,6 +146,21 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Tuinity start - optimise PlayerChunkMap#isOutsideRange
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, ChunkMapDistance.MOB_SPAWN_RANGE);
         // Tuinity end - optimise PlayerChunkMap#isOutsideRange
+
+        // Tuinity start - use distance map to optimise entity tracker
+        // force propagate tracker changes
+        if (this.optimisedTrackerEnabled) {
+            for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+                com.tuinity.tuinity.util.map.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+                com.tuinity.tuinity.util.map.PlayerAreaMap untrackMap = this.playerEntityTrackerUntrackMaps[i];
+                int trackRange = this.entityTrackerTrackRanges[i];
+                int untrackRange = this.entityTrackerUntrackRanges[i];
+
+                trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, effectiveViewDistance));
+                untrackMap.update(player, chunkX, chunkZ, Math.min(untrackRange, effectiveViewDistance));
+            }
+        }
+        // Tuinity end - use distance map to optimise entity tracker
     }
 
     final class ChunkSendThrottler {
@@ -364,6 +379,27 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     // Tuinity end - optimise PlayerChunkMap#isOutsideRange
 
+    // Tuinity start - use distance map to optimise entity tracker
+    public final boolean optimisedTrackerEnabled;
+
+    // inlined EnumMap, TrackingRange.TrackingRangeType
+    static final org.spigotmc.TrackingRange.TrackingRangeType[] TRACKING_RANGE_TYPES = org.spigotmc.TrackingRange.TrackingRangeType.values();
+    final com.tuinity.tuinity.util.map.PlayerAreaMap[] playerEntityTrackerTrackMaps;
+    final com.tuinity.tuinity.util.map.PlayerAreaMap[] playerEntityTrackerUntrackMaps;
+    final int[] entityTrackerTrackRanges;
+    final int[] entityTrackerUntrackRanges;
+
+    final com.tuinity.tuinity.util.EntityList activelyTrackedEntitiesLegacy;
+
+    public static boolean isLegacyTrackingEntity(Entity entity) {
+        return entity.isLegacyTrackingEntity;
+    }
+
+    private static int getEntityTrackingChunkRange(int blockRange) {
+        return blockRange >>> 4 + ((blockRange & 15) != 0 ? 1 : 0);
+    }
+    // Tuinity end - use distance map to optimise entity tracker
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         this.updateMaps(player);
 
@@ -416,6 +452,17 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.playerMobSpawnMap.remove(player);
         this.playerChunkTickRangeMap.remove(player);
         // Tuinity end - optimise PlayerChunkMap#isOutsideRange
+
+        // Tuinity start - use distance map to optimise entity tracker
+        if (this.optimisedTrackerEnabled) {
+            for (com.tuinity.tuinity.util.map.PlayerAreaMap trackMap : this.playerEntityTrackerTrackMaps) {
+                trackMap.remove(player);
+            }
+            for (com.tuinity.tuinity.util.map.PlayerAreaMap trackMap : this.playerEntityTrackerUntrackMaps) {
+                trackMap.remove(player);
+            }
+        }
+        // Tuinity end - use distance map to optimise entity tracker
     }
 
     void updateDistanceMapsTuinity(EntityPlayer player) {
@@ -444,6 +491,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Tuinity start - optimise PlayerChunkMap#isOutsideRange
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, ChunkMapDistance.MOB_SPAWN_RANGE);
         // Tuinity end - optimise PlayerChunkMap#isOutsideRange
+
+        // Tuinity start - use distance map to optimise entity tracker
+        if (this.optimisedTrackerEnabled) {
+            for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+                com.tuinity.tuinity.util.map.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+                com.tuinity.tuinity.util.map.PlayerAreaMap untrackMap = this.playerEntityTrackerUntrackMaps[i];
+                int trackRange = this.entityTrackerTrackRanges[i];
+                int untrackRange = this.entityTrackerUntrackRanges[i];
+
+                trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, effectiveViewDistance));
+                untrackMap.update(player, chunkX, chunkZ, Math.min(untrackRange, effectiveViewDistance));
+            }
+        }
+        // Tuinity end - use distance map to optimise entity tracker
     }
     // Tuinity end
 
@@ -557,6 +618,103 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     }
                 });
         // Tuinity end
+
+        // Tuinity start - use distance map to optimise entity tracker
+        if (!this.world.tuinityConfig.useOptimizedTracker) {
+            this.activelyTrackedEntitiesLegacy = null;
+            this.playerEntityTrackerTrackMaps = null;
+            this.playerEntityTrackerUntrackMaps = null;
+            this.entityTrackerTrackRanges = null;
+            this.entityTrackerUntrackRanges = null;
+            this.optimisedTrackerEnabled = false;
+        } else {
+            this.optimisedTrackerEnabled = true;
+            this.activelyTrackedEntitiesLegacy = new com.tuinity.tuinity.util.EntityList();
+
+            this.playerEntityTrackerTrackMaps = new com.tuinity.tuinity.util.map.PlayerAreaMap[TRACKING_RANGE_TYPES.length];
+            this.playerEntityTrackerUntrackMaps = new com.tuinity.tuinity.util.map.PlayerAreaMap[TRACKING_RANGE_TYPES.length];
+            this.entityTrackerTrackRanges = new int[TRACKING_RANGE_TYPES.length];
+            this.entityTrackerUntrackRanges = new int[TRACKING_RANGE_TYPES.length];
+
+            org.spigotmc.SpigotWorldConfig spigotWorldConfig = this.world.spigotConfig;
+
+            for (int ordinal = 0, len = TRACKING_RANGE_TYPES.length; ordinal < len; ++ordinal) {
+                org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = TRACKING_RANGE_TYPES[ordinal];
+                int configuredSpigotValue;
+                switch (trackingRangeType) {
+                    case PLAYER:
+                        configuredSpigotValue = spigotWorldConfig.playerTrackingRange;
+                        break;
+                    case ANIMAL:
+                        configuredSpigotValue = spigotWorldConfig.animalTrackingRange;
+                        break;
+                    case MONSTER:
+                        configuredSpigotValue = spigotWorldConfig.monsterTrackingRange;
+                        break;
+                    case MISC:
+                        configuredSpigotValue = spigotWorldConfig.miscTrackingRange;
+                        break;
+                    case OTHER:
+                        configuredSpigotValue = spigotWorldConfig.otherTrackingRange;
+                        break;
+                    case ENDERDRAGON:
+                        configuredSpigotValue = 10 * 16; // default is 10 chunk range // TODO check on update
+                        break;
+                    default:
+                        throw new IllegalStateException("Missing case for enum " + trackingRangeType);
+                }
+
+                int untrackRange = Math.max(1, getEntityTrackingChunkRange(configuredSpigotValue));
+                int trackRange = untrackRange - 1;
+                this.entityTrackerTrackRanges[ordinal] = trackRange;
+                this.entityTrackerUntrackRanges[ordinal] = untrackRange;
+
+                this.playerEntityTrackerTrackMaps[ordinal] = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                        (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                         com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                            Chunk chunk = PlayerChunkMap.this.world.getChunkProvider().getChunkAtIfLoadedMainThreadNoCache(rangeX, rangeZ);
+                            if (chunk == null || !player.loadedChunks.contains(com.tuinity.tuinity.util.Util.getCoordinateKey(rangeX, rangeZ))) {
+                                return;
+                            }
+                            Entity[] entities = chunk.entities.getRawData();
+                            for (int index = 0, length = chunk.entities.size(); index < length; ++index) {
+                                Entity entity = entities[index];
+                                if (org.spigotmc.TrackingRange.getTrackingRangeType(entity) != trackingRangeType) {
+                                    continue;
+                                }
+                                if (entity.tracker == null) {
+                                    entity.addToTrackQueue(player);
+                                } else {
+                                    entity.tracker.updateTrackingPlayer(player);
+                                    entity.clearTrackingQueues(player);
+                                }
+                            }
+                        },
+                        null);
+                this.playerEntityTrackerUntrackMaps[ordinal] = new com.tuinity.tuinity.util.map.PlayerAreaMap(sets,
+                        null,
+                        (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                         com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                            Chunk chunk = PlayerChunkMap.this.world.getChunkProvider().getChunkAtIfCachedImmediately(rangeX, rangeZ);
+                            if (chunk == null) {
+                                return;
+                            }
+                            Entity[] entities = chunk.entities.getRawData();
+                            for (int index = 0, length = chunk.entities.size(); index < length; ++index) {
+                                Entity entity = entities[index];
+                                if (entity.tracker == null) {
+                                    return; // not tracked by player for sure
+                                }
+                                if (org.spigotmc.TrackingRange.getTrackingRangeType(entity) != trackingRangeType) {
+                                    continue;
+                                }
+                                entity.tracker.removeTrackingPlayer(player);
+                                entity.clearTrackingQueues(player);
+                            }
+                        });
+            }
+        }
+        // Tuinity end - use distance map to optimise entity tracker
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -1779,6 +1937,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     public void movePlayer(EntityPlayer entityplayer) {
+        if (!this.optimisedTrackerEnabled) { // Tuinity - optimized tracker
         ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -1790,6 +1949,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 playerchunkmap_entitytracker.updatePlayer(entityplayer);
             }
         }
+        } // Tuinity - optimized tracker
 
         int i = MathHelper.floor(entityplayer.locX()) >> 4;
         int j = MathHelper.floor(entityplayer.locZ()) >> 4;
@@ -1894,11 +2054,37 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
                     entity.tracker = playerchunkmap_entitytracker; // Paper - Fast access to tracker
                     this.trackedEntities.put(entity.getId(), playerchunkmap_entitytracker);
+                    if (!this.optimisedTrackerEnabled) { // Tuinity - implement optimized tracker
                     playerchunkmap_entitytracker.track(this.world.getPlayers());
+                        // Tuinity start - implement optimized tracker
+                    } else {
+                        entity.acquireTrackingMap(this);
+                        if (PlayerChunkMap.isLegacyTrackingEntity(entity)) {
+                            this.activelyTrackedEntitiesLegacy.add(entity);
+                            // tracker tick will propagate updates
+                        } else {
+                            int chunkX = com.tuinity.tuinity.util.Util.getChunkCoordinate(entity.locX());
+                            int chunkZ = com.tuinity.tuinity.util.Util.getChunkCoordinate(entity.locZ());
+                            com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> playersTracking = entity.trackingAreaMap.getObjectsInRange(chunkX, chunkZ);
+                            if (playersTracking != null) {
+                                Object[] backingSet = playersTracking.getBackingSet();
+                                for (int index = 0, len = backingSet.length; index < len; ++index) {
+                                    Object temp = backingSet[index];
+                                    if (!(temp instanceof EntityPlayer)) {
+                                        continue;
+                                    }
+                                    EntityPlayer trackingPlayer = (EntityPlayer)temp;
+                                    playerchunkmap_entitytracker.updateTrackingPlayer(trackingPlayer);
+                                }
+                            }
+                        }
+                    }
+                    // Tuinity end - implement optimized tracker
                     if (entity instanceof EntityPlayer) {
                         EntityPlayer entityplayer = (EntityPlayer) entity;
 
                         this.a(entityplayer, true);
+                        if (!this.optimisedTrackerEnabled) { // Tuinity - implement optimized tracker
                         ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
                         while (objectiterator.hasNext()) {
@@ -1908,6 +2094,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                                 playerchunkmap_entitytracker1.updatePlayer(entityplayer);
                             }
                         }
+                        } // Tuinity - implement optimized tracker
                     }
 
                 }
@@ -1936,9 +2123,105 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             playerchunkmap_entitytracker1.a();
         }
         entity.tracker = null; // Paper - We're no longer tracked
+        // Tuinity start - optimise entity tracking - we're no longer tracked
+        if (this.activelyTrackedEntitiesLegacy != null) {
+            this.activelyTrackedEntitiesLegacy.remove(entity);
+        }
+        entity.releaseTrackingMap(this);
+        // Tuinity end - optimise entity tracking - we're no longer tracked
     }
 
+    // Tuinity start - optimized tracker
+    private void processTrackQueue() {
+        // handle queued changes
+
+        this.world.timings.tracker1.startTiming();
+        for (Entity tracked : this.world.trackingUpdateQueue) {
+            EntityTracker tracker = tracked.tracker;
+            if (tracker == null) {
+                continue;
+            }
+            // queued tracks
+            for (it.unimi.dsi.fastutil.ints.IntIterator iterator = tracked.trackQueue.iterator(); iterator.hasNext();) {
+                int id = iterator.nextInt();
+                Entity player = this.world.entitiesById.get(id);
+
+                if (!(player instanceof EntityPlayer)) {
+                    continue;
+                }
+
+                // double-check to make sure we're in range...
+                int chunkX = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locX());
+                int chunkZ = com.tuinity.tuinity.util.Util.getChunkCoordinate(player.locZ());
+
+                com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange =
+                        tracked.unTrackingAreaMap.getObjectsInRange(chunkX, chunkZ);
+
+                if (inRange != null && inRange.contains(player)) {
+                    tracker.updateTrackingPlayer((EntityPlayer)player);
+                } else {
+                    tracker.removeTrackingPlayer((EntityPlayer)player);
+                }
+            }
+            tracked.trackQueue.clear();
+
+            // queued untracks
+            for (it.unimi.dsi.fastutil.ints.IntIterator iterator = tracked.unTrackQueue.iterator(); iterator.hasNext();) {
+                int id = iterator.nextInt();
+                Entity player = this.world.entitiesById.get(id);
+
+                if (!(player instanceof EntityPlayer)) {
+                    continue;
+                }
+
+                tracker.removeTrackingPlayer((EntityPlayer)player);
+            }
+            tracked.unTrackQueue.clear();
+        }
+        this.world.trackingUpdateQueue.clear();
+        this.world.timings.tracker1.stopTiming();
+
+        // broadcast updates
+
+        this.world.timings.tracker2.startTiming();
+        for (Entity tracked : this.world.loadedEntities) {
+            EntityTracker tracker = tracked.tracker;
+            if (tracker != null) {
+                tracker.trackerEntry.tick();
+            }
+        }
+        this.world.timings.tracker2.stopTiming();
+
+        // legacy tracker
+
+        this.world.timings.tracker3.startTiming();
+        Entity[] legacyEntities = this.activelyTrackedEntitiesLegacy.getRawData();
+        for (int i = 0, size = this.activelyTrackedEntitiesLegacy.size(); i < size; ++i) {
+            Entity entity = legacyEntities[i];
+            EntityTracker tracker = this.trackedEntities.get(entity.getId());
+            if (tracker == null) {
+                MinecraftServer.LOGGER.error("Legacy tracking entity has no tracker! No longer tracking entity " + entity);
+                this.activelyTrackedEntitiesLegacy.remove(entity);
+                --i;
+                --size;
+                continue;
+            }
+
+            EntityTrackerEntry entry = tracker.trackerEntry;
+            tracker.track(this.world.getPlayers());
+            entry.tick(); // always tick the entry, even if no player is tracking
+        }
+        this.world.timings.tracker3.stopTiming();
+    }
+    // Tuinity end - optimized tracker
+
     protected void g() {
+        // Tuinity start - optimized tracker
+        if (this.optimisedTrackerEnabled) {
+            this.processTrackQueue();
+            return;
+        }
+        // Tuinity end - optimized tracker
         List<EntityPlayer> list = Lists.newArrayList();
         List<EntityPlayer> list1 = this.world.getPlayers();
 
@@ -2007,6 +2290,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         PacketDebug.a(this.world, chunk.getPos());
         List<Entity> list = Lists.newArrayList();
         List<Entity> list1 = Lists.newArrayList();
+        if (!this.optimisedTrackerEnabled) { // Tuinity - implement optimized tracker
         ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -2024,6 +2308,31 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 }
             }
         }
+            // Tuinity  start- implement optimized tracker
+        } else {
+            // Tuinity - implement optimized tracker
+            // Tuinity start - implement optimized tracker
+            // It's important to note that this is ONLY called when the chunk is at ticking level.
+            // At this point, the entities should be added in the chunk.
+            // only send entities when they're in tracking range...
+            Entity[] entities = chunk.entities.getRawData();
+            for (int i = 0, len = chunk.entities.size(); i < len; ++i) {
+                Entity entityInChunk = entities[i];
+                com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> playersInRange
+                        = entityInChunk.trackingAreaMap.getObjectsInRange(chunk.getPos());
+                if (playersInRange == null || !playersInRange.contains(entityplayer)) {
+                    continue;
+                }
+                PlayerChunkMap.EntityTracker tracker = entityInChunk.tracker;
+                if (tracker == null) {
+                    continue;
+                }
+
+                // Note: We don't add to the lists because the track logic will handle it
+                tracker.updateTrackingPlayer(entityplayer);
+            }
+        }
+        // Tuinity end - implement optimized tracker
 
         Iterator iterator;
         Entity entity1;
@@ -2061,7 +2370,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     public class EntityTracker {
 
-        private final EntityTrackerEntry trackerEntry;
+        final EntityTrackerEntry trackerEntry; // Tuinity - private -> package private
         private final Entity tracker;
         private final int trackingDistance;
         private SectionPosition e;
@@ -2184,6 +2493,42 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             return i;
         }
 
+        // Tuinity start - optimized tracker
+        final void updateTrackingPlayer(EntityPlayer entityplayer) {
+            if (entityplayer == this.tracker) {
+                return;
+            }
+            com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Tracker update"); // Tuinity
+            // the same as updatePlayer except without a distance check
+            // we also add a world check since we queue tracking changes
+            // TODO check on update
+            // CraftBukkit start - respect vanish API
+            boolean shouldTrack = entityplayer.world == tracker.world && entityplayer.loadedChunks.contains(com.tuinity.tuinity.util.Util.getCoordinateKey(this.tracker));
+            if (this.tracker instanceof EntityPlayer) {
+                Player player = ((EntityPlayer)this.tracker).getBukkitEntity();
+                if (!entityplayer.getBukkitEntity().canSee(player)) {
+                    shouldTrack = false;
+                }
+            }
+            // CraftBukkit end
+
+            if (shouldTrack) {
+                if (this.trackedPlayerMap.putIfAbsent(entityplayer, true) == null) { // Paper
+                    this.trackerEntry.onTrack(entityplayer);
+                }
+            } else {
+                this.removeTrackingPlayer(entityplayer);
+            }
+        }
+
+        final void removeTrackingPlayer(EntityPlayer player) {
+            com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Tracker update"); // Tuinity
+            if (this.trackedPlayers.remove(player)) {
+                this.trackerEntry.onUntrack(player);
+            }
+        }
+        // Tuinity end - optimized tracker
+
         public void track(List<EntityPlayer> list) {
             Iterator iterator = list.iterator();
 
diff --git a/src/main/java/net/minecraft/server/Ticket.java b/src/main/java/net/minecraft/server/Ticket.java
index 7a8397815a5b7f79f3e3a0348aeedf63fe879f8f..0d5b1a0b7b922587afac523b4de8059809b56f65 100644
--- a/src/main/java/net/minecraft/server/Ticket.java
+++ b/src/main/java/net/minecraft/server/Ticket.java
@@ -5,9 +5,10 @@ import java.util.Objects;
 public final class Ticket<T> implements Comparable<Ticket<?>> {
 
     private final TicketType<T> a;
-    private final int b;
+    private int b; public final void setTicketLevel(final int value) { this.b = value; } // Tuinity - remove final, add set OBFHELPER
     public final T identifier; public final T getObjectReason() { return this.identifier; } // Paper - OBFHELPER
-    private long d; public final long getCreationTick() { return this.d; } // Paper - OBFHELPER
+    private long d; public final long getCreationTick() { return this.d; } public final void setCreationTick(final long value) { this.d = value; }  // Paper - OBFHELPER // Tuinity - OBFHELPER
+    boolean isCached; // Tuinity - delay chunk unloads, this defends against really stupid plugins
 
     protected Ticket(TicketType<T> tickettype, int i, T t0) {
         this.a = tickettype;
@@ -60,6 +61,7 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
         this.d = i;
     }
 
+    protected final boolean isExpired(long time) { return this.b(time); } // Tuinity - OBFHELPER
     protected boolean b(long i) {
         long j = this.a.b();
 
diff --git a/src/main/java/net/minecraft/server/TicketType.java b/src/main/java/net/minecraft/server/TicketType.java
index 4b87ca2ecb6d738908fba111f52e54be463cc809..141664b5545a11c7d382c4e6ea155693d700ce50 100644
--- a/src/main/java/net/minecraft/server/TicketType.java
+++ b/src/main/java/net/minecraft/server/TicketType.java
@@ -23,6 +23,7 @@ public class TicketType<T> {
     public static final TicketType<org.bukkit.plugin.Plugin> PLUGIN_TICKET = a("plugin_ticket", (plugin1, plugin2) -> plugin1.getClass().getName().compareTo(plugin2.getClass().getName())); // CraftBukkit
     public static final TicketType<Integer> ANTIXRAY = a("antixray", Integer::compareTo); // Paper - Anti-Xray
     public static final TicketType<Long> ASYNC_LOAD = a("async_load", Long::compareTo); // Paper
+    public static final TicketType<Long> DELAYED_UNLOAD = a("delayed_unload", Long::compareTo); // Tuinity - delay chunk unloads by 30 seconds
 
     public static <T> TicketType<T> a(String s, Comparator<T> comparator) {
         return new TicketType<>(s, comparator, 0L);
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 51b3c9d561152acb1f4b5adf72e9939a5f32675a..5d6f08f2969e65510fc41fff29e7c097a5792144 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -82,6 +82,8 @@ public class WorldServer extends World {
         return new Throwable(entity + " Added to world at " + new java.util.Date());
     }
 
+    final com.tuinity.tuinity.util.EntityList trackingUpdateQueue = new com.tuinity.tuinity.util.EntityList(); // Tuinity - optimise tracker
+
     // Paper start - optimise getPlayerByUUID
     @Nullable
     @Override
@@ -829,6 +831,10 @@ public class WorldServer extends World {
         int k = MathHelper.floor(entity.locZ() / 16.0D);
 
         if (!entity.inChunk || entity.chunkX != i || entity.chunkY != j || entity.chunkZ != k) {
+            // Tuinity start - optimized tracker
+            int prevChunkX = entity.chunkX;
+            int prevChunkZ = entity.chunkZ;
+            // Tuinity end - optimized tracker
             if (entity.inChunk && this.isChunkLoaded(entity.chunkX, entity.chunkZ)) {
                 this.getChunkAt(entity.chunkX, entity.chunkZ).a(entity, entity.chunkY);
             }
@@ -838,6 +844,83 @@ public class WorldServer extends World {
             } else {
                 this.getChunkAt(i, k).a(entity);
             }
+            // Tuinity start - optimized tracker
+            int newChunkX = entity.chunkX;
+            int newChunkZ = entity.chunkZ;
+            if (entity.valid && (prevChunkX != newChunkX || prevChunkZ != newChunkZ)) {
+                PlayerChunkMap chunkMap = this.getChunkProvider().playerChunkMap;
+                if (chunkMap.optimisedTrackerEnabled) {
+                    if (!PlayerChunkMap.isLegacyTrackingEntity(entity)) {
+                        // handle tracking
+                        com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> oldRange =
+                                entity.trackingAreaMap.getObjectsInRange(prevChunkX, prevChunkZ);
+                        com.tuinity.tuinity.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newRange =
+                                entity.trackingAreaMap.getObjectsInRange(newChunkX, newChunkZ);
+
+                        if (oldRange != newRange) { // optimization: equal pooled sets are identity equal
+                            if (newRange != null) {
+                                if (oldRange == null) {
+                                    Object[] backingSet = newRange.getBackingSet();
+                                    for (int index = 0, len = backingSet.length; index < len; ++index) {
+                                        Object temp = backingSet[index];
+                                        if (!(temp instanceof EntityPlayer)) {
+                                            continue;
+                                        }
+                                        EntityPlayer player = (EntityPlayer) temp;
+                                        entity.addToTrackQueue(player);
+                                    }
+                                } else {
+                                    Object[] backingSet = newRange.getBackingSet();
+                                    for (int index = 0, len = backingSet.length; index < len; ++index) {
+                                        Object temp = backingSet[index];
+                                        if (!(temp instanceof EntityPlayer)) {
+                                            continue;
+                                        }
+                                        EntityPlayer player = (EntityPlayer) temp;
+                                        if (oldRange.contains(player)) {
+                                            continue;
+                                        }
+                                        entity.addToTrackQueue(player);
+                                    }
+                                }
+                            }
+                        }
+
+                        // handle untracking
+                        oldRange = entity.unTrackingAreaMap.getObjectsInRange(prevChunkX, prevChunkZ);
+                        newRange = entity.unTrackingAreaMap.getObjectsInRange(newChunkX, newChunkZ);
+                        if (oldRange != newRange) { // optimization: equal pooled sets are identity equal
+                            if (oldRange != null) {
+                                if (newRange == null) {
+                                    Object[] backingSet = oldRange.getBackingSet();
+                                    for (int index = 0, len = backingSet.length; index < len; ++index) {
+                                        Object temp = backingSet[index];
+                                        if (!(temp instanceof EntityPlayer)) {
+                                            continue;
+                                        }
+                                        EntityPlayer player = (EntityPlayer) temp;
+                                        entity.addToUntrackQueue(player);
+                                    }
+                                } else {
+                                    Object[] backingSet = oldRange.getBackingSet();
+                                    for (int index = 0, len = backingSet.length; index < len; ++index) {
+                                        Object temp = backingSet[index];
+                                        if (!(temp instanceof EntityPlayer)) {
+                                            continue;
+                                        }
+                                        EntityPlayer player = (EntityPlayer) temp;
+                                        if (newRange.contains(player)) {
+                                            continue;
+                                        }
+                                        entity.addToUntrackQueue(player);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            // Tuinity end - optimized tracker
         }
 
         this.getMethodProfiler().exit();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index e175da85f6008102de36b6bee6d98f6347c809e6..8e818e766fce3d7f96b0a18de5b6db1c5096fc54 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -459,6 +459,7 @@ public class CraftWorld implements World {
         net.minecraft.server.IChunkAccess chunk = world.getChunkProvider().getChunkAt(x, z, ChunkStatus.FULL, false);
         if (chunk != null) {
             world.getChunkProvider().removeTicket(TicketType.PLUGIN, chunk.getPos(), 1, Unit.INSTANCE);
+            ((ChunkMapDistance)world.getChunkProvider().playerChunkMap.getChunkMapDistanceManager()).removeTickets(ChunkCoordIntPair.pair(x, z), TicketType.DELAYED_UNLOAD); // Tuinity - delay chunk unloads - let plugins override
         }
 
         return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 651ff6647398747199cbfcc5f49b8ccd707609af..b5ffd144139babb6619c1916ef96f4156be8669a 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1275,7 +1275,13 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         PlayerChunkMap.EntityTracker entry = tracker.trackedEntities.get(other.getId());
         if (entry != null && !entry.trackedPlayers.contains(getHandle())) {
+            if (!getHandle().getWorldServer().getChunkProvider().playerChunkMap.optimisedTrackerEnabled || PlayerChunkMap.isLegacyTrackingEntity(other)) { // Tuinity - optimized tracker
             entry.updatePlayer(getHandle());
+                // Tuinity start - optimized tracker
+            } else {
+                other.addToTrackQueue(getHandle());
+            }
+            // Tuinity end - optimized tracker
         }
     }
     // Paper start
diff --git a/src/main/java/org/spigotmc/TrackingRange.java b/src/main/java/org/spigotmc/TrackingRange.java
index 46c33e6917e6e81afcd85f1a15a841ce8ba333fc..76a4d4315272c3caa70c98c666869be471fd912f 100644
--- a/src/main/java/org/spigotmc/TrackingRange.java
+++ b/src/main/java/org/spigotmc/TrackingRange.java
@@ -47,4 +47,44 @@ public class TrackingRange
             return config.otherTrackingRange;
         }
     }
+
+    // Tuinity start - optimise entity tracking
+    // copied from above, TODO check on update
+    public static TrackingRangeType getTrackingRangeType(Entity entity)
+    {
+        SpigotWorldConfig config = entity.world.spigotConfig;
+        if ( entity instanceof EntityPlayer )
+        {
+            return TrackingRangeType.PLAYER;
+            // Paper start - Simplify and set water mobs to animal tracking range
+        }
+        switch (entity.activationType) {
+            case RAIDER:
+            case MONSTER:
+                return TrackingRangeType.MONSTER;
+            case WATER:
+            case ANIMAL:
+                return TrackingRangeType.ANIMAL;
+            case MISC:
+        }
+        if ( entity instanceof EntityItemFrame || entity instanceof EntityPainting || entity instanceof EntityItem || entity instanceof EntityExperienceOrb )
+        // Paper end
+        {
+            return TrackingRangeType.MISC;
+        } else
+        {
+            if (entity instanceof EntityEnderDragon) return TrackingRangeType.ENDERDRAGON; // Paper - enderdragon is exempt
+            return TrackingRangeType.OTHER;
+        }
+    }
+
+    public static enum TrackingRangeType {
+        PLAYER,
+        ANIMAL,
+        MONSTER,
+        MISC,
+        OTHER,
+        ENDERDRAGON;
+    }
+    // Tuinity end
 }
