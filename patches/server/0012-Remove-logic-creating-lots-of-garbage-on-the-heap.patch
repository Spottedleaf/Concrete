From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 27 Aug 2019 15:08:24 -0700
Subject: [PATCH] Remove logic creating lots of garbage on the heap

- PathfinderGoalSelector showed up at the top in memory profiling due
to streams

- ChunkMapDistance showed up at the top too due to bad iterator usage

- PlayerChunkMap#move and ChunkMap showed near the top when moving
around due to avoidable ChunkCoordIntPair allocations

- PathFinderNormal allocates a block position when checking the path
type of a block

- Either.Left/Right do not cache the optional returned for left()/right()
 (getChunk type calls all have to go through them...)

- ObjectAVLTreeSet does not override removeIf, so the default uses
an iterator. removeIf is invoked heavily in ChunkMapDistance (on every
tick). Replace with an impl that caches the iterator

- Some lighting stuff allocating AtomicInteger for passing a second
return value from a function. use a field since the JIT is not stack
allocating the variable

- Randomly ticking a block would allocate a BlockPosition, replace
with mutable pos

- Entity iteration for ticking would use a non-fast iterator, thus
creating lots of garbage entries.

- Replace how the chunk map and light data is updated
   Before the underlying maps were copy on write, however this obviously
   will not scale well at all for large player counts. The replacement is
   a system which will queue updates to a map locked by a seqlock.
   Intentionally, the constructors/fields were clobbered, breaking
   the ABI.

- Vec3d allocation by tracker for checking a simple delta

- Iterator usage in hot areas

diff --git a/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedAbstractDoubleList.java b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedAbstractDoubleList.java
new file mode 100644
index 0000000000000000000000000000000000000000..54b1878ccec21be399af4b89fff10ae94c03ad88
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedAbstractDoubleList.java
@@ -0,0 +1,39 @@
+package ca.spottedleaf.concrete.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.List;
+
+public abstract class ExtendedAbstractDoubleList extends AbstractDoubleList {
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedDoubleArrayList.java b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedDoubleArrayList.java
new file mode 100644
index 0000000000000000000000000000000000000000..37a0fd2eb8473517f40877e9b784bb4a8c0e3013
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedDoubleArrayList.java
@@ -0,0 +1,65 @@
+package ca.spottedleaf.concrete.util.fastutil;
+
+import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
+import it.unimi.dsi.fastutil.doubles.DoubleList;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class ExtendedDoubleArrayList extends DoubleArrayList {
+
+    public ExtendedDoubleArrayList() {
+        super();
+    }
+
+    public ExtendedDoubleArrayList(final int capacity) {
+        super(capacity);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array) {
+        this(array, array.length, true);
+    }
+
+    public ExtendedDoubleArrayList(final double[] array, final int size, final boolean copy) {
+        super(copy ? array.clone() : array, false);
+        this.size = size;
+    }
+
+    public static ExtendedDoubleArrayList getList(final double[] list, final int requiredLength) {
+        if (list.length == requiredLength) {
+            return new ExtendedDoubleArrayList(list, requiredLength, false);
+        } else {
+            return new ExtendedDoubleArrayList(Arrays.copyOf(list, requiredLength), requiredLength, false);
+        }
+    }
+
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (!(other instanceof DoubleList)) {
+            if (other instanceof List) {
+                return super.equals(other);
+            }
+            return false;
+        }
+
+        final DoubleList otherList = (DoubleList)other;
+
+        final int otherSize = otherList.size();
+        final int thisSize = this.size();
+
+        if (otherSize != thisSize) {
+            return false;
+        }
+
+        for (int i = 0; i < thisSize; ++i) {
+            if (this.getDouble(i) != otherList.getDouble(i)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..2206beca4d39d4c12c3c8d1fbd7d0549618e46cf
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/fastutil/ExtendedObjectAVLTreeSet.java
@@ -0,0 +1,90 @@
+package ca.spottedleaf.concrete.util.fastutil;
+
+import it.unimi.dsi.fastutil.objects.ObjectAVLTreeSet;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+
+import java.lang.reflect.Field;
+import java.util.function.Predicate;
+
+public class ExtendedObjectAVLTreeSet<K> extends ObjectAVLTreeSet<K> {
+
+    private static final Field PREV_FIELD;
+    private static final Field NEXT_FIELD;
+    private static final Field CURR_FIELD;
+    private static final Field INDEX_FIELD;
+
+    private static final Integer ZERO = Integer.valueOf(0);
+
+    static {
+        try {
+            final Class clazz = Class.forName(ObjectAVLTreeSet.class.getCanonicalName() + "$SetIterator");
+            PREV_FIELD = clazz.getDeclaredField("prev");
+            PREV_FIELD.setAccessible(true);
+
+            NEXT_FIELD = clazz.getDeclaredField("next");
+            NEXT_FIELD.setAccessible(true);
+
+            CURR_FIELD = clazz.getDeclaredField("curr");
+            CURR_FIELD.setAccessible(true);
+
+            INDEX_FIELD = clazz.getDeclaredField("index");
+            INDEX_FIELD.setAccessible(true);
+        } catch (final Throwable thr) {
+            throw new RuntimeException(thr);
+        }
+    }
+
+    private ObjectBidirectionalIterator<K> cachedIterator = this.iterator();
+
+    {
+        this.nullIterator(this.cachedIterator);
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super K> filter) {
+        if (this.isEmpty()) {
+            return false;
+        }
+
+        if (this.cachedIterator == null) {
+            return super.removeIf(filter); // recursive...?
+        }
+
+        final ObjectBidirectionalIterator<K> iterator = this.cachedIterator;
+        this.cachedIterator = null;
+        this.startIterator(iterator);
+
+        boolean ret = false;
+
+        while (iterator.hasNext()) {
+            if (filter.test(iterator.next())) {
+                ret = true;
+                iterator.remove();
+            }
+        }
+
+        this.nullIterator(iterator);
+        this.cachedIterator = iterator;
+        return ret;
+    }
+
+    private void startIterator(final ObjectBidirectionalIterator<K> iterator) {
+        // assume iterator is null'd
+        try {
+            NEXT_FIELD.set(iterator, this.firstEntry);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+
+    private void nullIterator(final ObjectBidirectionalIterator<K> iterator) {
+        try {
+            PREV_FIELD.set(iterator, null);
+            NEXT_FIELD.set(iterator, null);
+            CURR_FIELD.set(iterator, null);
+            INDEX_FIELD.set(iterator, ZERO);
+        } catch (final IllegalAccessException ex) {
+            throw new RuntimeException(ex); // not going to occur
+        }
+    }
+}
diff --git a/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java b/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java
new file mode 100644
index 0000000000000000000000000000000000000000..2438dba81884f6fc5f5a83961fa27fecf72e3182
--- /dev/null
+++ b/src/main/java/ca/spottedleaf/concrete/util/pool/PooledBlockPositions.java
@@ -0,0 +1,40 @@
+package ca.spottedleaf.concrete.util.pool;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MinecraftServer;
+
+public class PooledBlockPositions {
+
+    private static final int BLOCK_POOL_SIZE = 8192;
+
+    private static final BlockPosition.MutableBlockPosition[] POOL = new BlockPosition.MutableBlockPosition[BLOCK_POOL_SIZE];
+    private static int used = 0; // exclusive index of used positions
+
+    static {
+        for (int i = 0; i < BLOCK_POOL_SIZE; ++i) {
+            POOL[i] = new BlockPosition.MutableBlockPosition();
+        }
+    }
+
+    public static BlockPosition.MutableBlockPosition get(final int x, final int y, final int z) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed >= POOL.length) {
+            return new BlockPosition.MutableBlockPosition(x, y, z);
+        }
+        used = currentUsed + 1;
+
+        final BlockPosition.MutableBlockPosition ret = POOL[currentUsed];
+        POOL[currentUsed] = null;
+
+        return ret.setValues(x, y, z);
+    }
+
+    public static void ret(final BlockPosition.MutableBlockPosition position) {
+        final int currentUsed = used;
+        if (Thread.currentThread() != MinecraftServer.getServer().serverThread || currentUsed == 0) {
+            return;
+        }
+
+        POOL[used = currentUsed - 1] = position;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/PaperCommand.java b/src/main/java/com/destroystokyo/paper/PaperCommand.java
index 132397b3f36e10d2eee266c257cecd96373015ff..662e6af3c2c77ed655b665397838b1869e55f429 100644
--- a/src/main/java/com/destroystokyo/paper/PaperCommand.java
+++ b/src/main/java/com/destroystokyo/paper/PaperCommand.java
@@ -215,7 +215,7 @@ public class PaperCommand extends Command {
             int ticking = 0;
             int entityTicking = 0;
 
-            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.updatingChunks.values()) {
+            for (PlayerChunk chunk : world.getChunkProvider().playerChunkMap.chunkMap.getUpdatingValues()) { /* Concrete - replace chunk map */
                 if (chunk.getFullChunkIfCached() == null) {
                     continue;
                 }
diff --git a/src/main/java/com/mojang/datafixers/util/Either.java b/src/main/java/com/mojang/datafixers/util/Either.java
index a90adac7bd7ebd423f480e9ae0f44cb9d521fa4f..19763d89e5b2b09223b6a44fa11a7cfa179ec116 100644
--- a/src/main/java/com/mojang/datafixers/util/Either.java
+++ b/src/main/java/com/mojang/datafixers/util/Either.java
@@ -23,6 +23,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Left<L, R> extends Either<L, R> {
         private final L value;
+        private Optional<L> cachedLeft; /* Concrete - reduce allocation of these for chunks... */
 
         public Left(final L value) {
             this.value = value;
@@ -51,7 +52,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<L> left() {
-            return Optional.of(value);
+            return this.cachedLeft == null ? this.cachedLeft = Optional.of(value) : this.cachedLeft; /* Concrete - cache optional */
         }
 
         @Override
@@ -84,6 +85,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
     private static final class Right<L, R> extends Either<L, R> {
         private final R value;
+        private Optional<R> cachedRight; /* Concrete - reduce allocation of these for chunks... */
 
         public Right(final R value) {
             this.value = value;
@@ -117,7 +119,7 @@ public abstract class Either<L, R> implements App<Either.Mu<R>, L> {
 
         @Override
         public Optional<R> right() {
-            return Optional.of(value);
+            return this.cachedRight == null ? this.cachedRight = Optional.of(value) : this.cachedRight; /* Concrete - cache optional */
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index f6c917e38838fb4d8ba964edb36af50d931b706f..0c1d3b68f77295a4eb860c1274ced28064c512f4 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -450,6 +450,7 @@ public class BlockPosition extends BaseBlockPosition implements MinecraftSeriali
             return this.d(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
         }
 
+        public final BlockPosition.MutableBlockPosition setValues(final BaseBlockPosition baseblockposition) { return this.g(baseblockposition); } /* Concrete - OBFHELPER */
         public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
             return this.d(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
         }
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 0d3307990cda1a8945ab73a2782ea504c5afe067..1d49034b803a051440766a4b62a2616cb31a1ed2 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -695,7 +695,7 @@ public class Chunk implements IChunkAccess {
     public PlayerChunk playerChunk; /* Concrete - cache PlayerChunk per Chunk */
     public void loadCallback() {
         /* Concrete start - neighbour cache */
-        this.playerChunk = ((WorldServer)this.world).getChunkProvider().playerChunkMap.updatingChunks.get(this.coordinateKey);
+        this.playerChunk = ((WorldServer)this.world).getChunkProvider().playerChunkMap.chunkMap.getUpdating(this.coordinateKey); /* Concrete */
         int chunkX = this.loc.x;
         int chunkZ = this.loc.z;
         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();
diff --git a/src/main/java/net/minecraft/server/ChunkMap.java b/src/main/java/net/minecraft/server/ChunkMap.java
index 55f9f4e6e7fddb2fcdbc1877d1bdfe8d3c9eff6f..50444a2f49f07e66ff9ea55dacc1819023ea6624 100644
--- a/src/main/java/net/minecraft/server/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/ChunkMap.java
@@ -13,9 +13,10 @@ public abstract class ChunkMap extends LightEngineGraph {
 
     @Override
     protected void a(long i, int j, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int k = chunkcoordintpair.x;
-        int l = chunkcoordintpair.z;
+        /* Concrete start - remove allocation of ChunkCoordIntPair */
+        int k = ChunkCoordIntPair.getX(i);
+        int l = ChunkCoordIntPair.getZ(i);
+        /* Concrete end */
 
         for (int i1 = -1; i1 <= 1; ++i1) {
             for (int j1 = -1; j1 <= 1; ++j1) {
@@ -32,9 +33,10 @@ public abstract class ChunkMap extends LightEngineGraph {
     @Override
     protected int a(long i, long j, int k) {
         int l = k;
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i);
-        int i1 = chunkcoordintpair.x;
-        int j1 = chunkcoordintpair.z;
+        /* Concrete start - remove allocation of ChunkCoordIntPair */
+        int i1 = ChunkCoordIntPair.getX(i);
+        int j1 = ChunkCoordIntPair.getZ(i);
+        /* Concrete end */
 
         for (int k1 = -1; k1 <= 1; ++k1) {
             for (int l1 = -1; l1 <= 1; ++l1) {
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index d73d6e7a07739e000d613eb2923a7fff0c3eb5fd..ca0efec1c42e1997e255dd06055b704028664e9a 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -351,7 +351,7 @@ public abstract class ChunkMapDistance {
         }
 
         public void a(int i) {
-            ObjectIterator objectiterator = this.a.long2ByteEntrySet().iterator();
+            ObjectIterator objectiterator = this.a.long2ByteEntrySet().fastIterator(); /* Concrete - use fast iterator (reduces entry creation) */
 
             while (objectiterator.hasNext()) {
                 it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
@@ -432,7 +432,7 @@ public abstract class ChunkMapDistance {
 
     class b extends ChunkMap {
 
-        protected final Long2ByteMap a = new Long2ByteOpenHashMap();
+        protected final Long2ByteOpenHashMap a = new Long2ByteOpenHashMap(); /* Concrete - change type for fast iterator */
         protected final int b;
 
         protected b(int i) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index e19ff330db07fb0a1dcd250c9d46153869eec12f..b09d33cb228ced761f2a44d4ca05c2a72b44bcb6 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -607,6 +607,12 @@ public class ChunkProviderServer extends IChunkProvider {
         this.clearCache();
     }
 
+    /* Concrete start */
+    final ca.spottedleaf.concrete.util.ChunkList entityTickingChunks = new ca.spottedleaf.concrete.util.ChunkList();
+    boolean isTickingChunks;
+    final it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap<Chunk> pendingEntityTickingChunkChanges = new it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap<>(16, 0.8f);
+    /* Concrete end */
+
     private void tickChunks() {
         long i = this.world.getTime();
         long j = i - this.lastTickTime;
@@ -644,11 +650,12 @@ public class ChunkProviderServer extends IChunkProvider {
 
             this.world.timings.countNaturalMobs.stopTiming(); // Paper - timings
             this.world.getMethodProfiler().exit();
-            this.playerChunkMap.f().forEach((playerchunk) -> {
-                Optional<Chunk> optional = ((Either) playerchunk.b().getNow(PlayerChunk.UNLOADED_CHUNK)).left();
-
-                if (optional.isPresent()) {
-                    Chunk chunk = (Chunk) optional.get();
+            /* Concrete start - replace chunk map */
+            this.isTickingChunks = true;
+            for (Chunk chunk : this.entityTickingChunks) {
+                PlayerChunk playerchunk = chunk.playerChunk;
+                if (playerchunk != null) { // make sure load event has been called along with the load logic we put there
+                    /* Concrete end */
 
                     this.world.getMethodProfiler().enter("broadcast");
                     this.world.timings.broadcastChunkUpdates.startTiming(); // Paper - timings
@@ -749,7 +756,22 @@ public class ChunkProviderServer extends IChunkProvider {
                         this.world.timings.chunkTicks.stopTiming(); // Spigot // Paper
                     }
                 }
-            });
+            }; /* Concrete */
+            /* Concrete start - replace chunk map */
+            this.isTickingChunks = false;
+            if (!this.pendingEntityTickingChunkChanges.isEmpty()) {
+                for (it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator<it.unimi.dsi.fastutil.objects.Object2BooleanMap.Entry<Chunk>> iterator = this.pendingEntityTickingChunkChanges.object2BooleanEntrySet().fastIterator(this.pendingEntityTickingChunkChanges.object2BooleanEntrySet().last()); iterator.hasPrevious(); ) {
+                    it.unimi.dsi.fastutil.objects.Object2BooleanMap.Entry<Chunk> entry = iterator.previous();
+
+                    if (entry.getBooleanValue()) {
+                        this.entityTickingChunks.add(entry.getKey());
+                    } else {
+                        this.entityTickingChunks.remove(entry.getKey());
+                    }
+                    iterator.remove();
+                }
+            }
+            /* Concrete end - replace chunk map */
             this.world.getMethodProfiler().enter("customSpawners");
             if (flag1) {
                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings
diff --git a/src/main/java/net/minecraft/server/DoubleListOffset.java b/src/main/java/net/minecraft/server/DoubleListOffset.java
index 73657f740731b9bc606e64d0a2a3f32a842db3f5..8dec9410868cef2b1b7974c4ff161f366587ef5c 100644
--- a/src/main/java/net/minecraft/server/DoubleListOffset.java
+++ b/src/main/java/net/minecraft/server/DoubleListOffset.java
@@ -3,7 +3,7 @@ package net.minecraft.server;
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 import it.unimi.dsi.fastutil.doubles.DoubleList;
 
-public class DoubleListOffset extends AbstractDoubleList {
+public class DoubleListOffset extends ca.spottedleaf.concrete.util.fastutil.ExtendedAbstractDoubleList { /* Concrete - remove iterator allocation */
 
     private final DoubleList a;
     private final double b;
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 7985f3074b8ef80e08598401868bcc273cb20129..33150621f6b545e5a57156e753c2903a65edacf6 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -1746,8 +1746,13 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void a(ChunkCoordIntPair chunkcoordintpair) {
+        /* Concrete start - remove ChunkCoordIntPair allocation */
+        this.sendChunkUnload(chunkcoordintpair.x, chunkcoordintpair.z);
+    }
+    public final void sendChunkUnload(int x, int z) {
+        /* Concrete end - remove ChunkCoordIntPair allocation */
         if (this.isAlive()) {
-            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkcoordintpair.x, chunkcoordintpair.z));
+            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(x, z)); /* Concrete */
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 0634356d37c5ade98aa846f8f2ef29a2cb648aac..cfc5690bc7f7fbc5aca3d0d6a42d462a0cae5ec7 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -125,8 +125,10 @@ public class EntityTrackerEntry {
                 ++this.o;
                 i = MathHelper.d(this.tracker.yaw * 256.0F / 360.0F);
                 j = MathHelper.d(this.tracker.pitch * 256.0F / 360.0F);
-                Vec3D vec3d = this.tracker.getPositionVector().d(PacketPlayOutEntity.a(this.xLoc, this.yLoc, this.zLoc));
-                boolean flag1 = vec3d.g() >= 7.62939453125E-6D;
+                double vec3d_dx = this.tracker.locX() - 2.44140625E-4D*(this.xLoc);
+                double vec3d_dy = this.tracker.locY() - 2.44140625E-4D*(this.yLoc);
+                double vec3d_dz = this.tracker.locZ() - 2.44140625E-4D*(this.zLoc);
+                boolean flag1 = (vec3d_dx * vec3d_dx + vec3d_dy * vec3d_dy + vec3d_dz * vec3d_dz) >= 7.62939453125E-6D;
                 Packet<?> packet1 = null;
                 boolean flag2 = flag1 || this.tickCounter % 60 == 0;
                 boolean flag3 = Math.abs(i - this.yRot) >= 1 || Math.abs(j - this.xRot) >= 1;
@@ -143,9 +145,11 @@ public class EntityTrackerEntry {
                 // CraftBukkit end
 
                 if (this.tickCounter > 0 || this.tracker instanceof EntityArrow) {
-                    long k = PacketPlayOutEntity.a(vec3d.x);
-                    long l = PacketPlayOutEntity.a(vec3d.y);
-                    long i1 = PacketPlayOutEntity.a(vec3d.z);
+                    /* Concrete start - remove allocation of Vec3d here */
+                    long k = PacketPlayOutEntity.a(vec3d_dx);
+                    long l = PacketPlayOutEntity.a(vec3d_dy);
+                    long i1 = PacketPlayOutEntity.a(vec3d_dz);
+                    /* Concrete end - remove allocation of Vec3d here */
                     boolean flag4 = k < -32768L || k > 32767L || l < -32768L || l > 32767L || i1 < -32768L || i1 > 32767L;
 
                     if (!flag4 && this.o <= 400 && !this.q && this.r == this.tracker.onGround) {
diff --git a/src/main/java/net/minecraft/server/LightEngineBlock.java b/src/main/java/net/minecraft/server/LightEngineBlock.java
index 93a972605c26aa757b9c915876f847da04fcb496..1b0eb662900c73a8b27ddeb3af4dec30f3aa3137 100644
--- a/src/main/java/net/minecraft/server/LightEngineBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineBlock.java
@@ -37,7 +37,7 @@ public final class LightEngineBlock extends LightEngineLayer<LightEngineStorageB
             if (enumdirection == null) {
                 return 15;
             } else {
-                MutableInt mutableint = new MutableInt();
+                MutableInt mutableint = this.lastLevel; /* Concrete - avoid allocation of MutableInt */
                 IBlockData iblockdata = this.a(j, mutableint);
 
                 if (mutableint.getValue() >= 15) {
diff --git a/src/main/java/net/minecraft/server/LightEngineLayer.java b/src/main/java/net/minecraft/server/LightEngineLayer.java
index f72ff8495bcf704c15040676b95c51fecb72b73a..684f3f8de24bf9993f8ca311bfc5092f91ae9515 100644
--- a/src/main/java/net/minecraft/server/LightEngineLayer.java
+++ b/src/main/java/net/minecraft/server/LightEngineLayer.java
@@ -11,7 +11,7 @@ public abstract class LightEngineLayer<M extends LightEngineStorageArray<M>, S e
     protected final EnumSkyBlock b;
     protected final S c;
     private boolean f;
-    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition();
+    protected final BlockPosition.MutableBlockPosition d = new BlockPosition.MutableBlockPosition(); protected final MutableInt lastLevel = new MutableInt(); /* Concrete - avoid allocating MutableInt */
     private final long[] g = new long[2];
     private final IBlockAccess[] h = new IBlockAccess[2];
 
diff --git a/src/main/java/net/minecraft/server/LightEngineSky.java b/src/main/java/net/minecraft/server/LightEngineSky.java
index 2301a982e17ab9568e3da9ca84c4a024c7c1b214..02dffbfb76022d38622a85b46b0fb1efd3d6ed6d 100644
--- a/src/main/java/net/minecraft/server/LightEngineSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineSky.java
@@ -27,7 +27,7 @@ public final class LightEngineSky extends LightEngineLayer<LightEngineStorageSky
             if (k >= 15) {
                 return k;
             } else {
-                MutableInt mutableint = new MutableInt();
+                MutableInt mutableint = this.lastLevel; /* Concrete - avoid allocation of MutableInt */
                 IBlockData iblockdata = this.a(j, mutableint);
 
                 if (mutableint.getValue() >= 15) {
diff --git a/src/main/java/net/minecraft/server/LightEngineStorage.java b/src/main/java/net/minecraft/server/LightEngineStorage.java
index a3f919816eb2a742ed09b553995e6508684e5ea5..85a885a7271c9675f74c2a24c957ccc0de62c2c4 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorage.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorage.java
@@ -19,8 +19,8 @@ public abstract class LightEngineStorage<M extends LightEngineStorageArray<M>> e
     protected final LongSet b = new LongOpenHashSet();
     protected final LongSet c = new LongOpenHashSet();
     protected final LongSet d = new LongOpenHashSet();
-    protected volatile M e;
-    protected final M f;
+    protected volatile M e; /* Concrete - diff on change, should be "visible" */
+    protected final M f; /* Concrete - diff on change, should be "updating" */
     protected final LongSet g = new LongOpenHashSet();
     protected final LongSet h = new LongOpenHashSet();
     protected final Long2ObjectMap<NibbleArray> i = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap());
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageArray.java b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
index b978723a66d001f70325df0c7521025e079d7cfa..c1211a43d7672c067fd77cb67933e957e7481a0d 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageArray.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageArray.java
@@ -8,10 +8,17 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     private final long[] b = new long[2];
     private final NibbleArray[] c = new NibbleArray[2];
     private boolean d;
-    protected final Long2ObjectOpenHashMap<NibbleArray> a;
+    protected final ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> data; /* Concrete - avoid copying light data */
+    protected final boolean isVisible; /* Concrete - avoid copying light data */
 
-    protected LightEngineStorageArray(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-        this.a = long2objectopenhashmap;
+    /* Concrete start - avoid copying light data */
+    protected LightEngineStorageArray(ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> data, boolean isVisible) {
+        if (isVisible) {
+            data.performUpdatesLockMap();
+        }
+        this.data = data;
+        this.isVisible = isVisible;
+        /* Concrete end - avoid copying light data */
         this.c();
         this.d = true;
     }
@@ -19,12 +26,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
     public abstract M b();
 
     public void a(long i) {
-        this.a.put(i, ((NibbleArray) this.a.get(i)).b());
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } /* Concrete - avoid copying light data */
+        this.data.queueUpdate(i, ((NibbleArray) this.data.getUpdating(i)).b()); /* Concrete - avoid copying light data */
         this.c();
     }
 
     public boolean b(long i) {
-        return this.a.containsKey(i);
+        return this.isVisible ? this.data.getVisibleAsync(i) != null : this.data.getUpdating(i) != null; /* Concrete - avoid copying light data */
     }
 
     @Nullable
@@ -37,7 +45,7 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
             }
         }
 
-        NibbleArray nibblearray = (NibbleArray) this.a.get(i);
+        NibbleArray nibblearray = (NibbleArray) (this.isVisible ? this.data.getVisibleAsync(i) : this.data.getUpdating(i)); /* Concrete - avoid copying light data */
 
         if (nibblearray == null) {
             return null;
@@ -58,11 +66,13 @@ public abstract class LightEngineStorageArray<M extends LightEngineStorageArray<
 
     @Nullable
     public NibbleArray d(long i) {
-        return (NibbleArray) this.a.remove(i);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } /* Concrete - avoid copying light data */
+        return (NibbleArray) this.data.queueRemove(i); /* Concrete - avoid copying light data */
     }
 
     public void a(long i, NibbleArray nibblearray) {
-        this.a.put(i, nibblearray);
+        if (this.isVisible) { throw new IllegalStateException("writing to visible data"); } /* Concrete - avoid copying light data */
+        this.data.queueUpdate(i, nibblearray); /* Concrete - avoid copying light data */
     }
 
     public void c() {
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
index 0f7f4744d9f9e5174fb38ccc72248397a4b064ea..6d07cfb6b885353be772da278dc3ea1e59c3f214 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageBlock.java
@@ -5,7 +5,7 @@ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStorageBlock.a> {
 
     protected LightEngineStorageBlock(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new Long2ObjectOpenHashMap()));
+        super(EnumSkyBlock.BLOCK, ilightaccess, new LightEngineStorageBlock.a(new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<>(), false)); /* Concrete - avoid copying light data */
     }
 
     @Override
@@ -18,13 +18,13 @@ public class LightEngineStorageBlock extends LightEngineStorage<LightEngineStora
 
     public static final class a extends LightEngineStorageArray<LightEngineStorageBlock.a> {
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap) {
-            super(long2objectopenhashmap);
+        public a(ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> long2objectopenhashmap, boolean isVisible) { /* Concrete - avoid copying light data */
+            super(long2objectopenhashmap, isVisible); /* Concrete - avoid copying light data */
         }
 
         @Override
         public LightEngineStorageBlock.a b() {
-            return new LightEngineStorageBlock.a(this.a.clone());
+            return new a(this.data, true); /* Concrete - avoid copying light data */
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/LightEngineStorageSky.java b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
index 4c11a7c62176e1006da5e89836335395f6d80527..94df05e414ec34b85a2c9f9985601d39d3c7a7b1 100644
--- a/src/main/java/net/minecraft/server/LightEngineStorageSky.java
+++ b/src/main/java/net/minecraft/server/LightEngineStorageSky.java
@@ -17,7 +17,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     private volatile boolean p;
 
     protected LightEngineStorageSky(ILightAccess ilightaccess) {
-        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new Long2ObjectOpenHashMap(), new Long2IntOpenHashMap(), Integer.MAX_VALUE));
+        super(EnumSkyBlock.SKY, ilightaccess, new LightEngineStorageSky.a(new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<>(), new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Int(), Integer.MAX_VALUE)); /* Concrete - avoid copying light data */
     }
 
     @Override
@@ -25,7 +25,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
         long j = SectionPosition.e(i);
         int k = SectionPosition.c(j);
         LightEngineStorageSky.a lightenginestoragesky_a = (LightEngineStorageSky.a) this.e;
-        int l = lightenginestoragesky_a.c.get(SectionPosition.f(j));
+        int l = lightenginestoragesky_a.otherData.getVisibleAsync(SectionPosition.f(j)); /* Concrete - avoid copying light data */
 
         if (l != lightenginestoragesky_a.b && k < l) {
             NibbleArray nibblearray = this.a(lightenginestoragesky_a, j); /* Concrete - decompile fix */
@@ -54,14 +54,14 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         if (((LightEngineStorageSky.a) this.f).b > j) {
             ((LightEngineStorageSky.a) this.f).b = j;
-            ((LightEngineStorageSky.a) this.f).c.defaultReturnValue(((LightEngineStorageSky.a) this.f).b);
+            ((LightEngineStorageSky.a) this.f).otherData.queueDefaultReturnValue(((LightEngineStorageSky.a) this.f).b); /* Concrete - avoid copying light data */
         }
 
         long k = SectionPosition.f(i);
-        int l = ((LightEngineStorageSky.a) this.f).c.get(k);
+        int l = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(k); /* Concrete - avoid copying light data */
 
         if (l < j + 1) {
-            ((LightEngineStorageSky.a) this.f).c.put(k, j + 1);
+            ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(k, j + 1); /* Concrete - avoid copying light data */
             if (this.o.contains(k)) {
                 this.q(i);
                 if (l > ((LightEngineStorageSky.a) this.f).b) {
@@ -101,7 +101,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
         int k = SectionPosition.c(i);
 
-        if (((LightEngineStorageSky.a) this.f).c.get(j) == k + 1) {
+        if (((LightEngineStorageSky.a) this.f).otherData.getUpdating(j) == k + 1) { /* Concrete - avoid copying light data */
             long l;
 
             for (l = i; !this.g(l) && this.a(k); l = SectionPosition.a(l, EnumDirection.DOWN)) {
@@ -109,12 +109,12 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             }
 
             if (this.g(l)) {
-                ((LightEngineStorageSky.a) this.f).c.put(j, k + 1);
+                ((LightEngineStorageSky.a) this.f).otherData.queueUpdate(j, k + 1); /* Concrete - avoid copying light data */
                 if (flag) {
                     this.q(l);
                 }
             } else {
-                ((LightEngineStorageSky.a) this.f).c.remove(j);
+                ((LightEngineStorageSky.a) this.f).otherData.queueRemove(j); /* Concrete - avoid copying light data */
             }
         }
 
@@ -128,7 +128,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     protected void b(long i, boolean flag) {
         this.d();
         if (flag && this.o.add(i)) {
-            int j = ((LightEngineStorageSky.a) this.f).c.get(i);
+            int j = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(i); /* Concrete - avoid copying light data */
 
             if (j != ((LightEngineStorageSky.a) this.f).b) {
                 long k = SectionPosition.b(SectionPosition.b(i), j - 1, SectionPosition.d(i));
@@ -155,7 +155,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             return nibblearray;
         } else {
             long j = SectionPosition.a(i, EnumDirection.UP);
-            int k = ((LightEngineStorageSky.a) this.f).c.get(SectionPosition.f(i));
+            int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(SectionPosition.f(i)); /* Concrete - avoid copying light data */
 
             if (k != ((LightEngineStorageSky.a) this.f).b && SectionPosition.c(j) < k) {
                 NibbleArray nibblearray1;
@@ -298,7 +298,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
             if (!this.o.contains(l)) {
                 return false;
             } else {
-                int i1 = ((LightEngineStorageSky.a) this.f).c.get(l);
+                int i1 = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(l); /* Concrete - avoid copying light data */
 
                 return SectionPosition.c(i1) == j + 16;
             }
@@ -307,7 +307,7 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
 
     protected boolean n(long i) {
         long j = SectionPosition.f(i);
-        int k = ((LightEngineStorageSky.a) this.f).c.get(j);
+        int k = ((LightEngineStorageSky.a) this.f).otherData.getUpdating(j); /* Concrete - avoid copying light data */
 
         return k == ((LightEngineStorageSky.a) this.f).b || SectionPosition.c(i) >= k;
     }
@@ -321,18 +321,20 @@ public class LightEngineStorageSky extends LightEngineStorage<LightEngineStorage
     public static final class a extends LightEngineStorageArray<LightEngineStorageSky.a> {
 
         private int b;
-        private final Long2IntOpenHashMap c;
+        private final ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Int otherData; /* Concrete - avoid copying light data */
 
-        public a(Long2ObjectOpenHashMap<NibbleArray> long2objectopenhashmap, Long2IntOpenHashMap long2intopenhashmap, int i) {
-            super(long2objectopenhashmap);
-            this.c = long2intopenhashmap;
-            long2intopenhashmap.defaultReturnValue(i);
+        /* Concrete start - avoid copying light data */
+        public a(ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<NibbleArray> data, ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Int otherData, int i) {
+            super(data, false);
+            this.otherData = otherData;
+            /* Concrete end - avoid copying light data */
             this.b = i;
         }
 
         @Override
         public LightEngineStorageSky.a b() {
-            return new LightEngineStorageSky.a(this.a.clone(), this.c.clone(), this.b);
+            this.otherData.performUpdatesLockMap(); /* Concrete - avoid copying light data */
+            return new LightEngineStorageSky.a(this.data, this.otherData, this.b); /* Concrete - avoid copying light data */
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index c02c53b50bc1933c16b0dfe86eab9f506ab26c09..b2588240789542d09c55c71cd37c3a877cf8c23b 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -432,9 +432,9 @@ public final class MCUtil {
 
             WorldServer world = ((org.bukkit.craftbukkit.CraftWorld)bukkitWorld).getHandle();
             PlayerChunkMap chunkMap = world.getChunkProvider().playerChunkMap;
-            Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks = chunkMap.visibleChunks;
+            /* Concrete - replace chunk map */
             ChunkMapDistance chunkMapDistance = chunkMap.getChunkMapDistanceManager();
-            List<PlayerChunk> allChunks = new ArrayList<>(visibleChunks.values());
+            List<PlayerChunk> allChunks = chunkMap.chunkMap.getUpdatingValuesCopy(); /* Concrete - replace chunk map */
             List<EntityPlayer> players = world.players;
 
             int fullLoadedChunks = 0;
@@ -457,7 +457,7 @@ public final class MCUtil {
             worldData.addProperty("view-distance", world.spigotConfig.viewDistance);
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig.keepLoadedRange);
-            worldData.addProperty("visible-chunk-count", visibleChunks.size());
+            worldData.addProperty("visible-chunk-count", allChunks.size()); /* Concrete - replace chunk map */
             worldData.addProperty("loaded-chunk-count", chunkMap.loadedChunks.size());
             worldData.addProperty("verified-fully-loaded-chunks", fullLoadedChunks);
 
@@ -535,4 +535,28 @@ public final class MCUtil {
         // TODO make sure the constant `33` is correct on future updates. See getChunkAt(int, int, ChunkStatus, boolean)
         return 33 + ChunkStatus.getTicketLevelOffset(status);
     }
+
+    public static <E> boolean hasCommonElement(Set<E> set0, Set<E> set1) {
+        java.util.Iterator<E> iterator;
+        Set<E> target;
+
+        // optimize by iterating over fewest entries possible
+        if (set0.size() <= set1.size()) {
+            target = set1;
+            iterator = set0.iterator();
+        } else {
+            target = set0;
+            iterator = set1.iterator();
+        }
+
+        while (iterator.hasNext()) {
+            E element = iterator.next();
+            if (target.contains(element)) {
+                return true;
+            }
+        }
+
+        return false;
+
+    }
 }
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index 98deaba12ceb25f59d1b56420fb544a64b417ddd..eb4ce45b1d841a304cf8c055c0714ee37e0f4837 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -67,7 +67,7 @@ public class NBTTagCompound implements NBTBase {
     }
 
     public NBTTagCompound() {
-        this(Maps.newHashMap());
+        this(new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(16, 0.8f)); /* Concrete - reduce memory footprint of NBTTagCompound */
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/PairedQueue.java b/src/main/java/net/minecraft/server/PairedQueue.java
index 85bb22e4b7376b676139048f2d55684e27a54055..506cd658cce3bb194846928c38e9d6cdeb4ab47b 100644
--- a/src/main/java/net/minecraft/server/PairedQueue.java
+++ b/src/main/java/net/minecraft/server/PairedQueue.java
@@ -20,32 +20,30 @@ public interface PairedQueue<T, F> {
 
     public static final class a implements PairedQueue<PairedQueue.b, Runnable> {
 
-        private final List<Queue<Runnable>> a;
+        private final List<Queue<Runnable>> a; private final List<Queue<Runnable>> getQueues() { return this.a; } /* Concrete - OBFHELPER */
 
         public a(int i) {
-            this.a = (List) IntStream.range(0, i).mapToObj((j) -> {
-                return Queues.newConcurrentLinkedQueue();
-            }).collect(Collectors.toList());
+            /* Concrete start - reduce streams */
+            this.a = new java.util.ArrayList<>(i); // queues
+            for (int j = 0; j < i; ++j) {
+                this.getQueues().add(new ca.spottedleaf.concurrentutil.queue.MultiThreadedQueue<>()); // use MT queue
+            }
+            /* Concrete end - reduce streams */
         }
 
         @Nullable
         @Override
         public Runnable a() {
-            Iterator iterator = this.a.iterator();
-
-            Runnable runnable;
-
-            do {
-                if (!iterator.hasNext()) {
-                    return null;
+            /* Concrete start - reduce iterator creation */
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                Runnable ret = queue.poll();
+                if (ret != null) {
+                    return ret;
                 }
-
-                Queue<Runnable> queue = (Queue) iterator.next();
-
-                runnable = (Runnable) queue.poll();
-            } while (runnable == null);
-
-            return runnable;
+            }
+            return null;
+            /* Concrete end - reduce iterator creation */
         }
 
         public boolean a(PairedQueue.b pairedqueue_b) {
@@ -57,7 +55,15 @@ public interface PairedQueue<T, F> {
 
         @Override
         public boolean b() {
-            return this.a.stream().allMatch(Collection::isEmpty);
+            /* Concrete start - reduce streams */
+            for (int i = 0, len = this.getQueues().size(); i < len; ++i) {
+                Queue<Runnable> queue = this.getQueues().get(i);
+                if (!queue.isEmpty()) {
+                    return false;
+                }
+            }
+            return true;
+            /* Concrete end - reduce streams */
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderGoal.java b/src/main/java/net/minecraft/server/PathfinderGoal.java
index f22f12eeb0b10d038fcd74cc4b19e888b134c3c7..e5ac6d283f1357db56095fb50cfa02543253c3e2 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoal.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoal.java
@@ -1,10 +1,11 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.concrete.util.OptimizedSmallEnumSet; /* Concrete */
 import java.util.EnumSet;
 
 public abstract class PathfinderGoal {
 
-    private final EnumSet<PathfinderGoal.Type> a = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); /* Concrete - reduce garbage on heap */
 
     public PathfinderGoal() {}
 
@@ -25,16 +26,20 @@ public abstract class PathfinderGoal {
     public void e() {}
 
     public void a(EnumSet<PathfinderGoal.Type> enumset) {
-        this.a.clear();
-        this.a.addAll(enumset);
+        /* Concrete start - reduce garbage on heap */
+        this.goalTypes.clear();
+        this.goalTypes.addAllUnchecked(enumset);
+        /* Concrete end - reduce garbage on heap */
     }
 
     public String toString() {
         return this.getClass().getSimpleName();
     }
 
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a;
+    /* Concrete start - reduce garbage on heap */
+    public ca.spottedleaf.concrete.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.goalTypes;
+        /* Concrete end - reduce garbage on heap */
     }
 
     public static enum Type {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
index 44bb18c5945b69f09b3a6e6272f2c3a5477780c7..6efac5babf33bcef682751e9ce1829089d4c6e06 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.concrete.util.OptimizedSmallEnumSet;
 import com.google.common.collect.Sets;
 import java.util.EnumMap;
 import java.util.EnumSet;
+import java.util.Iterator; /* Concrete */
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Stream;
@@ -26,7 +28,7 @@ public class PathfinderGoalSelector {
     private final Map<PathfinderGoal.Type, PathfinderGoalWrapped> c = new EnumMap(PathfinderGoal.Type.class);
     private final Set<PathfinderGoalWrapped> d = Sets.newLinkedHashSet();
     private final GameProfilerFiller e;
-    private final EnumSet<PathfinderGoal.Type> f = EnumSet.noneOf(PathfinderGoal.Type.class);
+    private final OptimizedSmallEnumSet<PathfinderGoal.Type> goalTypes = new OptimizedSmallEnumSet<>(PathfinderGoal.Type.class); /* Concrete - reduce garbage on heap */
     private int g = 3;
 
     public PathfinderGoalSelector(GameProfilerFiller gameprofilerfiller) {
@@ -38,33 +40,38 @@ public class PathfinderGoalSelector {
     }
 
     public void a(PathfinderGoal pathfindergoal) {
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        }).filter(PathfinderGoalWrapped::g).forEach(PathfinderGoalWrapped::d);
-        this.d.removeIf((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.j() == pathfindergoal;
-        });
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped goalWrapped = iterator.next();
+            if (goalWrapped.j() != pathfindergoal) {
+                continue;
+            }
+            if (goalWrapped.g()) {
+                goalWrapped.d();
+            }
+            iterator.remove();
+        }
+        /* Concrete end */
     }
 
+    private static final PathfinderGoal.Type[] PATHFINDER_GOAL_TYPES = PathfinderGoal.Type.values();
+
     public void doTick() {
         this.e.enter("goalCleanup");
-        this.c().filter((pathfindergoalwrapped) -> {
-            boolean flag;
-
-            if (pathfindergoalwrapped.g()) {
-                Stream stream = pathfindergoalwrapped.i().stream();
-                EnumSet enumset = this.f;
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (!wrappedGoal.g()) {
+                continue;
+            }
 
-                this.f.getClass();
-                if (!stream.anyMatch(enumset::contains) && pathfindergoalwrapped.b()) {
-                    flag = false;
-                    return flag;
-                }
+            if (!this.goalTypes.hasCommonElements(wrappedGoal.getGoalTypes()) && wrappedGoal.b()) {
+                continue;
             }
 
-            flag = true;
-            return flag;
-        }).forEach(PathfinderGoal::d);
+            wrappedGoal.d();
+        }
+        /* Concrete end */
         this.c.forEach((pathfindergoal_type, pathfindergoalwrapped) -> {
             if (!pathfindergoalwrapped.g()) {
                 this.c.remove(pathfindergoal_type);
@@ -73,30 +80,54 @@ public class PathfinderGoalSelector {
         });
         this.e.exit();
         this.e.enter("goalUpdate");
-        this.d.stream().filter((pathfindergoalwrapped) -> {
-            return !pathfindergoalwrapped.g();
-        }).filter((pathfindergoalwrapped) -> {
-            Stream stream = pathfindergoalwrapped.i().stream();
-            EnumSet enumset = this.f;
-
-            this.f.getClass();
-            return stream.noneMatch(enumset::contains);
-        }).filter((pathfindergoalwrapped) -> {
-            return pathfindergoalwrapped.i().stream().allMatch((pathfindergoal_type) -> {
-                return ((PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b)).a(pathfindergoalwrapped);
-            });
-        }).filter(PathfinderGoalWrapped::a).forEach((pathfindergoalwrapped) -> {
-            pathfindergoalwrapped.i().forEach((pathfindergoal_type) -> {
-                PathfinderGoalWrapped pathfindergoalwrapped1 = (PathfinderGoalWrapped) this.c.getOrDefault(pathfindergoal_type, PathfinderGoalSelector.b);
-
-                pathfindergoalwrapped1.d();
-                this.c.put(pathfindergoal_type, pathfindergoalwrapped);
-            });
-            pathfindergoalwrapped.c();
-        });
+        /* Concrete start - remove streams */
+        goal_update_loop: for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                continue;
+            }
+
+            OptimizedSmallEnumSet<PathfinderGoal.Type> wrappedGoalSet = wrappedGoal.getGoalTypes();
+
+            if (this.goalTypes.hasCommonElements(wrappedGoalSet)) {
+                continue;
+            }
+
+            for (long iterator1 = wrappedGoalSet.getBackingSet(); iterator1 != 0;) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+                if (!wrapped.a(wrappedGoal)) {
+                    continue goal_update_loop;
+                }
+            }
+
+            if (!wrappedGoal.a()) {
+                continue;
+            }
+
+            for (long iterator1 = wrappedGoalSet.getBackingSet(); iterator1 != 0;) {
+                PathfinderGoal.Type type = PATHFINDER_GOAL_TYPES[Long.numberOfTrailingZeros(iterator1)];
+                iterator1 ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(iterator1);
+                PathfinderGoalWrapped wrapped = this.c.getOrDefault(type, PathfinderGoalSelector.b);
+
+                wrapped.d();
+                this.c.put(type, wrappedGoal);
+            }
+
+            wrappedGoal.c();
+        }
+        /* Concrete end */
         this.e.exit();
         this.e.enter("goalTick");
-        this.c().forEach(PathfinderGoalWrapped::e);
+        /* Concrete start - remove streams */
+        for (Iterator<PathfinderGoalWrapped> iterator = this.d.iterator(); iterator.hasNext();) {
+            PathfinderGoalWrapped wrappedGoal = iterator.next();
+            if (wrappedGoal.g()) {
+                wrappedGoal.e();
+            }
+        }
+        /* Concrete end */
         this.e.exit();
     }
 
@@ -105,11 +136,11 @@ public class PathfinderGoalSelector {
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.add(pathfindergoal_type);
+        this.goalTypes.addUnchecked(pathfindergoal_type); /* Concrete - reduce streams */
     }
 
     public void b(PathfinderGoal.Type pathfindergoal_type) {
-        this.f.remove(pathfindergoal_type);
+        this.goalTypes.removeUnchecked(pathfindergoal_type); /* Concrete - reduce streams */
     }
 
     public void a(PathfinderGoal.Type pathfindergoal_type, boolean flag) {
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
index 5a8c60ad909394413427851db8068ba79c058b63..9ff7392b736d3dc1bdec0d552373d63592b92dd3 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalWrapped.java
@@ -60,8 +60,10 @@ public class PathfinderGoalWrapped extends PathfinderGoal {
     }
 
     @Override
-    public EnumSet<PathfinderGoal.Type> i() {
-        return this.a.i();
+    /* Concrete start - reduce garbage on heap */
+    public ca.spottedleaf.concrete.util.OptimizedSmallEnumSet<PathfinderGoal.Type> getGoalTypes() {
+        return this.a.getGoalTypes();
+        /* Concrete end - reduce garbage on heap */
     }
 
     public boolean g() {
diff --git a/src/main/java/net/minecraft/server/PathfinderNormal.java b/src/main/java/net/minecraft/server/PathfinderNormal.java
index 4240ca81cb6debecc54dcf9a550e9d916dfa8f9f..34ba6145d6e9e39b50f4084157bde309a2b6e503 100644
--- a/src/main/java/net/minecraft/server/PathfinderNormal.java
+++ b/src/main/java/net/minecraft/server/PathfinderNormal.java
@@ -443,8 +443,10 @@ public class PathfinderNormal extends PathfinderAbstract {
         return pathtype;
     }
 
+    private static final BlockPosition.MutableBlockPosition PATH_TYPE_BLOCKPOSITION = new BlockPosition.MutableBlockPosition(); /* Concrete - this shows to be a high allocator */
+
     protected static PathType c(IBlockAccess iblockaccess, int i, int j, int k) {
-        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition = PATH_TYPE_BLOCKPOSITION.setValues(i, j, k); /* Concrete - this shows to be a high allocator */
         IBlockData iblockdata = iblockaccess.getTypeIfLoaded(blockposition); // Paper
         if (iblockdata == null) return PathType.BLOCKED; // Paper
         Block block = iblockdata.getBlock();
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index cb4c539277a20f020889c51438dd965138c37086..fb7e8626f73d47fc4cd439488dbf9fe56f230c32 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -436,6 +436,13 @@ public class PlayerChunk {
             this.entityTickingFuture = playerchunkmap.b(this.location); this.entityTickingFuture.thenAccept((either) -> {
                 if (either.left().isPresent()) {
                     PlayerChunk.this.isEntityTickingReady = true;
+                    ChunkProviderServer chunkProvder = PlayerChunk.this.chunkMap.world.getChunkProvider();
+                    Chunk chunk = either.left().get();
+                    if (chunkProvder.isTickingChunks) {
+                        chunkProvder.pendingEntityTickingChunkChanges.put(chunk, true);
+                    } else {
+                        chunkProvder.entityTickingChunks.add(chunk);
+                    }
                 }
             });
             /* Concrete end - cache chunk ticking stage */
@@ -445,6 +452,17 @@ public class PlayerChunk {
         if (flag6 && !flag7) {
             this.entityTickingFuture.complete(PlayerChunk.UNLOADED_CHUNK);
             this.isEntityTickingReady = false; /* Concrete - cache chunk ticking stage */
+            /* Concrete start */
+            ChunkProviderServer chunkProvder = PlayerChunk.this.chunkMap.world.getChunkProvider();
+            Chunk chunk = this.getFullChunkIfCached();
+            if (chunk != null) {
+                if (chunkProvder.isTickingChunks) {
+                    chunkProvder.pendingEntityTickingChunkChanges.put(chunk, false);
+                } else {
+                    chunkProvder.entityTickingChunks.remove(chunk);
+                }
+            }
+            /* Concrete end */
             this.entityTickingFuture = PlayerChunk.UNLOADED_CHUNK_FUTURE;
         }
 
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 964d99941489d599f36c58a87c19959b71f1e6b7..b6608203690ca998afe2e249a02d90307276c4b0 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -55,8 +55,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
-    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap();
-    public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks;
+    //public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new Long2ObjectLinkedOpenHashMap(); /* Concrete - replace chunk map */
+    //public volatile Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks; /* Concrete - replace chunk map */
+    public final ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<PlayerChunk> chunkMap = new ca.spottedleaf.concrete.chunk.QueuedChangesMapLong2Object<>(8192, 0.7f); /* Concrete - replace chunk map */
     private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
     final LongSet loadedChunks; // Paper - private -> package
     public final WorldServer world;
@@ -137,7 +138,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     public PlayerChunkMap(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator<?> chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i) {
         super(new File(worldserver.getWorldProvider().getDimensionManager().a(file), "region"), datafixer);
-        this.visibleChunks = this.updatingChunks.clone();
+        //this.visibleChunks = this.updatingChunks.clone(); /* Concrete - replace chunk map */
         this.pendingUnload = new Long2ObjectLinkedOpenHashMap();
         this.loadedChunks = new LongOpenHashSet();
         this.unloadQueue = new LongOpenHashSet();
@@ -228,8 +229,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     private static int a(ChunkCoordIntPair chunkcoordintpair, int i, int j) {
-        int k = chunkcoordintpair.x - i;
-        int l = chunkcoordintpair.z - j;
+        /* Concrete start - remove ChunkCoordIntPair allocation */
+        return getSquareRadiusDistance(chunkcoordintpair.x, chunkcoordintpair.z, i, j);
+    }
+    private static int getSquareRadiusDistance(int chunkX0, int chunkZ0, int i, int j) {
+        int k = chunkX0 - i;
+        int l = chunkZ0 - j;
+        /* Concrete end */
 
         return Math.max(Math.abs(k), Math.abs(l));
     }
@@ -240,12 +246,17 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Nullable
     protected PlayerChunk getUpdatingChunk(long i) {
-        return (PlayerChunk) this.updatingChunks.get(i);
+        return (PlayerChunk) this.chunkMap.getUpdating(i); /* Concrete - replace chunk map */
     }
 
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
-        return (PlayerChunk) this.visibleChunks.get(i);
+        /* Concrete start - replace chunk map */
+        if (MinecraftServer.getServer().serverThread == Thread.currentThread()) {
+            return this.chunkMap.getVisible(i);
+        }
+        return (PlayerChunk) this.chunkMap.getVisibleAsync(i);
+        /* Concrete end - replace chunk map */
     }
 
     protected IntSupplier c(long i) {
@@ -347,7 +358,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     playerchunk = new PlayerChunk(new ChunkCoordIntPair(i), j, this.lightEngine, this.p, this);
                 }
 
-                this.updatingChunks.put(i, playerchunk);
+                this.chunkMap.queueUpdate(i, playerchunk); /* Concrete - replace chunk map */
                 this.updatingChunksModified = true;
             }
 
@@ -370,7 +381,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - derived from below
     protected void saveIncrementally() {
         int savedThisTick = 0;
-        for (PlayerChunk playerchunk : visibleChunks.values()) {
+        for (PlayerChunk playerchunk : this.chunkMap.getVisibleValues()) { /* Concrete - replace chunk map */
             if (playerchunk.hasBeenLoaded()) {
 
                 IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
@@ -399,7 +410,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void save(boolean flag) {
         if (flag) {
-            List<PlayerChunk> list = (List) this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList());
+            List<PlayerChunk> list = (List) this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).peek(PlayerChunk::m).collect(Collectors.toList()); /* Concrete - replace chunk map */
             MutableBoolean mutableboolean = new MutableBoolean();
 
             do {
@@ -427,7 +438,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 //            this.i(); // Paper - nuke IOWorker
             PlayerChunkMap.LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", this.w.getName());
         } else {
-            this.visibleChunks.values().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> {
+            this.chunkMap.getVisibleValues().stream().filter(PlayerChunk::hasBeenLoaded).forEach((playerchunk) -> { /* Concrete - replace chunk map */
                 IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
 
                 if (ichunkaccess instanceof ProtoChunkExtension || ichunkaccess instanceof Chunk) {
@@ -470,7 +481,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         while (longiterator.hasNext()) { // Spigot
             long j = longiterator.nextLong();
             longiterator.remove(); // Spigot
-            PlayerChunk playerchunk = (PlayerChunk) this.updatingChunks.remove(j);
+            PlayerChunk playerchunk = (PlayerChunk) this.chunkMap.queueRemove(j); /* Concrete - replace chunk map */
 
             if (playerchunk != null) {
                 this.pendingUnload.put(j, playerchunk);
@@ -597,7 +608,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         if (!this.updatingChunksModified) {
             return false;
         } else {
-            this.visibleChunks = this.updatingChunks.clone();
+            this.chunkMap.performUpdates(); /* Concrete - replace chunk map */
             this.updatingChunksModified = false;
             return true;
         }
@@ -998,7 +1009,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
             this.viewDistance = j;
             this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+            Iterator objectiterator = this.chunkMap.getUpdatingValues().iterator(); /* Concrete - replace chunk map */
 
             while (objectiterator.hasNext()) {
                 PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
@@ -1018,9 +1029,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        /* Concrete start - remove ChunkCoordIntPair allocation, use two ints instead of ChunkCoordIntPair */
+        this.sendChunk(entityplayer, chunkcoordintpair.x, chunkcoordintpair.z, apacket, flag, flag1);
+    }
+    protected void sendChunk(EntityPlayer entityplayer, int chunkX, int chunkZ, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        /* Concrete end */
         if (entityplayer.world == this.world) {
             if (flag1 && !flag) {
-                PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
+                PlayerChunk playerchunk = this.getVisibleChunk(ChunkCoordIntPair.pair(chunkX, chunkZ)); /* Concrete - remove ChunkCoordIntPair allocation */
 
                 if (playerchunk != null) {
                     Chunk chunk = playerchunk.getChunk();
@@ -1029,19 +1045,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         this.a(entityplayer, apacket, chunk);
                     }
 
-                    PacketDebug.a(this.world, chunkcoordintpair);
+                    //PacketDebug.a(this.world, chunkcoordintpair); /* Concrete - remove ChunkCoordIntPair allocation (this function is a no-op) */
                 }
             }
 
             if (!flag1 && flag) {
-                entityplayer.a(chunkcoordintpair);
+                entityplayer.sendChunkUnload(chunkX, chunkZ); /* Concrete - remove ChunkCoordIntPair allocation */
             }
 
         }
     }
 
     public int d() {
-        return this.visibleChunks.size();
+        return this.chunkMap.getVisibleSizeAsync(); /* Concrete - replace chunk map */
     }
 
     protected PlayerChunkMap.a e() {
@@ -1049,12 +1065,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected Iterable<PlayerChunk> f() {
-        return Iterables.unmodifiableIterable(this.visibleChunks.values());
+        return Iterables.unmodifiableIterable(this.chunkMap.getUpdatingValuesCopy()); /* Concrete - replace chunk map */
     }
 
     void a(Writer writer) throws IOException {
         CSVWriter csvwriter = CSVWriter.a().a("x").a("z").a("level").a("in_memory").a("status").a("full_status").a("accessible_ready").a("ticking_ready").a("entity_ticking_ready").a("ticket").a("spawning").a("entity_count").a("block_entity_count").a(writer);
-        ObjectBidirectionalIterator objectbidirectionaliterator = this.visibleChunks.long2ObjectEntrySet().iterator();
+        ObjectBidirectionalIterator objectbidirectionaliterator = this.chunkMap.getVisibleMap().long2ObjectEntrySet().iterator(); /* Concrete - replace chunk map */
 
         while (objectbidirectionaliterator.hasNext()) {
             Entry<PlayerChunk> entry = (Entry) objectbidirectionaliterator.next();
@@ -1295,11 +1311,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
+        Packet[] cachedPackets = new Packet[2]; /* Concrete */
         for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
             for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
-
-                this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
+                /* Concrete start - remove excess object creation (ChunkCoordIntPair and Packet[]) */
+                this.sendChunk(entityplayer, k, l, cachedPackets, !flag, flag);
+                java.util.Arrays.fill(cachedPackets, null);
+                /* Concrete end */
             }
         }
 
@@ -1371,35 +1389,47 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             int i2 = Math.max(i, i1) + this.viewDistance;
             int j2 = Math.max(j, j1) + this.viewDistance;
 
+            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    boolean flag3 = getSquareRadiusDistance(k2, l2, i1, j1) <= this.viewDistance;
+                    boolean flag4 = getSquareRadiusDistance(k2, l2, i, j) <= this.viewDistance;
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+                    this.sendChunk(entityplayer, k2, l2, cachedPackets, flag3, flag4);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
         } else {
-            ChunkCoordIntPair chunkcoordintpair1;
+            //ChunkCoordIntPair chunkcoordintpair1; /* Concrete - we don't set, so compile fail on further uses */
             boolean flag5;
             boolean flag6;
 
+            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+
             for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
                 for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    /* Concrete - remove ChunkCoordIntPair allocation */
                     flag5 = true;
                     flag6 = false;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, true, false);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
 
             for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
                 for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
+                    /* Concrete - remove ChunkCoordIntPair allocation */
                     flag5 = false;
                     flag6 = true;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+                    /* Concrete start - remove ChunkCoordIntPair allocation */
+                    this.sendChunk(entityplayer, k1, l1, cachedPackets, false, true);
+                    java.util.Arrays.fill(cachedPackets, null);
+                    /* Concrete end */
                 }
             }
         }
@@ -1663,10 +1693,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         public void updatePlayer(EntityPlayer entityplayer) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
-                Vec3D vec3d = entityplayer.getPositionVector().d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
+                /* Concrete start - remove allocation of Vec3d here */
+                double vec3d_dx = entityplayer.locX() - this.tracker.locX();
+                double vec3d_dy = entityplayer.locY() - this.tracker.locY();
+                double vec3d_dz = entityplayer.locZ() - this.tracker.locZ();
+                /* Concrete end - remove allocation of Vec3d here */
                 int i = Math.min(this.b(), (PlayerChunkMap.this.viewDistance - 1) * 16);
-                boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
-
+                boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.tracker.a(entityplayer); /* Concrete start - remove allocation of Vec3d here */
                 if (flag) {
                     boolean flag1 = this.tracker.attachedToPlayer;
 
diff --git a/src/main/java/net/minecraft/server/PlayerInventory.java b/src/main/java/net/minecraft/server/PlayerInventory.java
index d117578f29d926851230a524fe41eb251dcc573b..84d45e0e3f7aceaeded92b7135cb2ecf690f04a5 100644
--- a/src/main/java/net/minecraft/server/PlayerInventory.java
+++ b/src/main/java/net/minecraft/server/PlayerInventory.java
@@ -559,8 +559,10 @@ public class PlayerInventory implements IInventory, INamableTileEntity {
 
         NonNullList nonnulllist;
 
-        for (Iterator iterator = this.f.iterator(); iterator.hasNext(); i -= nonnulllist.size()) {
-            nonnulllist = (NonNullList) iterator.next();
+        /* Concrete start - reduce iterator creation */
+        for (int index = 0, len = this.f.size(); index < len; ++index, i -= nonnulllist.size()) {
+            nonnulllist = this.f.get(index);
+            /* Concrete end - reduce iterator creation */
             if (i < nonnulllist.size()) {
                 list = nonnulllist;
                 break;
diff --git a/src/main/java/net/minecraft/server/VoxelShapeArray.java b/src/main/java/net/minecraft/server/VoxelShapeArray.java
index caf297fe977942ca68fdb963d97dd9fc0f78d883..9fea1cf40b430d1c4302d179f6764a5d178ea120 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeArray.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeArray.java
@@ -11,7 +11,7 @@ public final class VoxelShapeArray extends VoxelShape {
     private final DoubleList d;
 
     protected VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, double[] adouble, double[] adouble1, double[] adouble2) {
-        this(voxelshapediscrete, (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble, voxelshapediscrete.b() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble1, voxelshapediscrete.c() + 1)), (DoubleList) DoubleArrayList.wrap(Arrays.copyOf(adouble2, voxelshapediscrete.d() + 1)));
+        this(voxelshapediscrete, ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList.getList(adouble, voxelshapediscrete.b() + 1), ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList.getList(adouble1, voxelshapediscrete.c() + 1), ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList.getList(adouble2, voxelshapediscrete.d() + 1)); /* Concrete - remove iterator allocation */
     }
 
     VoxelShapeArray(VoxelShapeDiscrete voxelshapediscrete, DoubleList doublelist, DoubleList doublelist1, DoubleList doublelist2) {
diff --git a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
index 9e09671dc24cfcd3bfe872cacdeb0a5d7e83c112..c46089463f8df75e00ff12c6dec4a92494ae262e 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeCubePoint.java
@@ -2,7 +2,7 @@ package net.minecraft.server;
 
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
-public class VoxelShapeCubePoint extends AbstractDoubleList {
+public class VoxelShapeCubePoint extends ca.spottedleaf.concrete.util.fastutil.ExtendedAbstractDoubleList { /* Concrete - remove iterator allocation */
 
     private final int a;
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
index 550620b5fe441d9b7438f334c5997a832f51878a..c316a4c23a31c5c1f470cbf856a1a3e8f445e05e 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeMergerList.java
@@ -18,7 +18,7 @@ public final class VoxelShapeMergerList implements VoxelShapeMerger {
         int l = doublelist1.size();
         int i1 = k + l;
 
-        this.a = new DoubleArrayList(i1);
+        this.a = new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(i1); /* Concrete - remove iterator creation */
         this.b = new IntArrayList(i1);
         this.c = new IntArrayList(i1);
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index 08c83c62dfe875600162a46a0ca4b835b0bfe199..731ed7a7a6e9784719e18806b37e1c401ddacd45 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -19,7 +19,7 @@ public final class VoxelShapes {
         return new VoxelShapeCube(voxelshapebitset);
     });
     public static final VoxelShape a = create(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
-    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}));
+    private static final VoxelShape c = new VoxelShapeArray(new VoxelShapeBitSet(0, 0, 0), new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D}), new ca.spottedleaf.concrete.util.fastutil.ExtendedDoubleArrayList(new double[]{0.0D})); /* Concrete - remove iterator allocation */
 
     public static VoxelShape a() {
         return VoxelShapes.c;
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index a990e54e88c2821cf6db440cb1f5e3684afa5a04..e0dbd66301c0f13720d7c6d8c710defe62391e98 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1589,10 +1589,19 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     public abstract TagRegistry t();
 
     public BlockPosition a(int i, int j, int k, int l) {
+        /* Concrete start - this function has a very high allocation rate */
+        BlockPosition.MutableBlockPosition ret = new BlockPosition.MutableBlockPosition();
+        this.getRandomBlockPosition(i, j, k, l, ret);
+        return ret.immutableCopy();
+    }
+
+    public BlockPosition.MutableBlockPosition getRandomBlockPosition(int i, int j, int k, int l, BlockPosition.MutableBlockPosition out) {
+        /* Concrete end */
         this.i = this.i * 3 + 1013904223;
         int i1 = this.i >> 2;
 
-        return new BlockPosition(i + (i1 & 15), j + (i1 >> 16 & l), k + (i1 >> 8 & 15));
+        out.setValues(i + (i1 & 15), j + (i1 >> 16 & l), k + (i1 >> 8 & 15)); /* Concrete - change to setValues call */
+        return out; /* Concrete */
     }
 
     public boolean isSavingDisabled() {
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 41f18043a830bcb9bda77be964568105bad7b3a6..2f4f188e8c7189b60c3fdd5a2759796a6bab7b41 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -55,7 +55,7 @@ public class WorldServer extends World {
 
     private static final Logger LOGGER = LogManager.getLogger();
     private final List<Entity> globalEntityList = Lists.newArrayList();
-    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
+    public final Int2ObjectLinkedOpenHashMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); /* Concrete - change type for fast iterator */
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
@@ -449,7 +449,7 @@ public class WorldServer extends World {
 
             gameprofilerfiller.exitEnter("regular");
             this.tickingEntities = true;
-            ObjectIterator objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+            ObjectIterator objectiterator = this.entitiesById.int2ObjectEntrySet().fastIterator(); /* Concrete - use fast iterator to reduce entry creation */
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
@@ -523,6 +523,8 @@ public class WorldServer extends World {
         });
     }
 
+    private final BlockPosition.MutableBlockPosition chunkTickMutablePosition = new BlockPosition.MutableBlockPosition(); /* Concrete - use mutable to reduce allocation rate */
+
     public void a(Chunk chunk, int i) {
         ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
         boolean flag = this.isRaining();
@@ -531,10 +533,10 @@ public class WorldServer extends World {
         GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
 
         gameprofilerfiller.enter("thunder");
-        BlockPosition blockposition;
+        final BlockPosition.MutableBlockPosition blockposition = this.chunkTickMutablePosition; /* Concrete - use mutable to reduce allocation rate, final to force compile fail on change */
 
         if (!this.paperConfig.disableThunder && flag && this.U() && this.random.nextInt(100000) == 0) { // Paper - Disable thunder
-            blockposition = this.a(this.a(j, 0, k, 15));
+            blockposition.setValues(this.a(this.getRandomBlockPosition(j, 0, k, 15, blockposition))); /* Concrete - use mutable to reduce allocation rate */
             if (this.isRainingAt(blockposition)) {
                 DifficultyDamageScaler difficultydamagescaler = this.getDamageScaler(blockposition);
                 boolean flag1 = this.getGameRules().getBoolean(GameRules.DO_MOB_SPAWNING) && this.random.nextDouble() < (double) difficultydamagescaler.b() * paperConfig.skeleHorseSpawnChance; // Paper
@@ -554,7 +556,7 @@ public class WorldServer extends World {
 
         gameprofilerfiller.exitEnter("iceandsnow");
         if (!this.paperConfig.disableIceAndSnow && this.random.nextInt(16) == 0) { // Paper - Disable ice and snow
-            blockposition = this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.a(j, 0, k, 15));
+            blockposition.setValues(this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.getRandomBlockPosition(j, 0, k, 15, blockposition))); /* Concrete - use mutable to reduce allocation rate */
             BlockPosition blockposition1 = blockposition.down();
             BiomeBase biomebase = this.getBiome(blockposition);
 
@@ -584,7 +586,7 @@ public class WorldServer extends World {
                     int j1 = chunksection.getYPosition();
 
                     for (int k1 = 0; k1 < i; ++k1) {
-                        BlockPosition blockposition2 = this.a(j, j1, k, 15);
+                        BlockPosition blockposition2 = this.getRandomBlockPosition(j, j1, k, 15, blockposition); /* Concrete - use mutable to reduce allocation rate */
 
                         gameprofilerfiller.enter("randomTick");
                         IBlockData iblockdata = chunksection.getType(blockposition2.getX() - j, blockposition2.getY() - j1, blockposition2.getZ() - k);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 4d7a7a8fe8290ce5a0fb5288f4eb9687dc61ae53..1772193517ae9e2f82d29ee8668a88f9f6285826 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -288,9 +288,9 @@ public class CraftWorld implements World {
     }
     public int getTileEntityCount() {
         // We don't use the full world tile entity list, so we must iterate chunks
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
+        Iterable<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); /* Concrete - replace chunk map */
         int size = 0;
-        for (net.minecraft.server.PlayerChunk playerchunk : chunks.values()) {
+        for (net.minecraft.server.PlayerChunk playerchunk : chunks) { /* Concrete - replace chunk map */
             net.minecraft.server.Chunk chunk = playerchunk.getChunk();
             if (chunk == null) {
                 continue;
@@ -305,7 +305,7 @@ public class CraftWorld implements World {
     public int getChunkCount() {
         int ret = 0;
 
-        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.visibleChunks.values()) {
+        for (PlayerChunk chunkHolder : world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues()) { /* Concrete - replace chunk map */
             if (chunkHolder.getChunk() != null) {
                 ++ret;
             }
@@ -433,8 +433,8 @@ public class CraftWorld implements World {
 
     @Override
     public Chunk[] getLoadedChunks() {
-        Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
-        return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
+        Collection<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.chunkMap.getVisibleValues(); /* Concrete - replace chunk map */
+        return chunks.stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new); /* Concrete - replace chunk map */
     }
 
     @Override
