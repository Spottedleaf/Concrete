From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 5 Jan 2020 17:17:41 -0800
Subject: [PATCH] Flush packets async

Apparently sendPacket took 50% of the timings for entity tracker
update, so offload that to the packet flusher thread.

diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 0490675ac9f01097f428fde5e4d457bc552adb5e..871210383d5d4fd0ea01e6c6d0eafd5337390bcb 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -66,6 +66,43 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
     private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush");
     // Paper end
 
+    /* Concrete start - flush packets async */
+    static final class PacketFlusher extends Thread {
+
+        public final java.util.Set<NetworkManager> needsUpdating = java.util.concurrent.ConcurrentHashMap.newKeySet();
+
+        @Override
+        public void run() {
+            java.util.ArrayDeque<NetworkManager> keep = new java.util.ArrayDeque<>();
+            for (;;) {
+                for (java.util.Iterator<NetworkManager> iterator = this.needsUpdating.iterator(); iterator.hasNext();) {
+                    NetworkManager needsUpdate = iterator.next();
+                    iterator.remove();
+
+                    if (!needsUpdate.sendPacketQueue()) {
+                        keep.add(needsUpdate);
+                    }
+                }
+
+                if (this.needsUpdating.isEmpty()) {
+                    try {
+                        Thread.sleep(1);
+                    } catch (InterruptedException ex) {}
+                }
+
+                for (int i = 0, len = keep.size(); i < len; ++i) {
+                    this.needsUpdating.add(keep.poll());
+                }
+            }
+        }
+    }
+
+    static final PacketFlusher PACKET_FLUSHER = new PacketFlusher();
+    static {
+        PACKET_FLUSHER.start();
+    }
+    /* Concrete end - flush packets async */
+
     public NetworkManager(EnumProtocolDirection enumprotocoldirection) {
         this.h = enumprotocoldirection;
     }
@@ -164,11 +201,12 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     public void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
-        if (this.isConnected() && this.sendPacketQueue() && !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the packet queue contains chunk packets which are not ready to the packet queue and send the packets later in the right order
+        if (!(this.packetListener instanceof PlayerConnection) && this.isConnected() && this.sendPacketQueue() && !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the packet queue contains chunk packets which are not ready to the packet queue and send the packets later in the right order /* Concrete - this is packet flusher's job now */
             //this.o(); // Paper - Async-Anti-Xray - Move to if statement (this.sendPacketQueue())
             this.b(packet, genericfuturelistener);
         } else {
             this.packetQueue.add(new NetworkManager.QueuedPacket(packet, genericfuturelistener));
+            PACKET_FLUSHER.needsUpdating.add(this); /* Concrete - this is packet flusher's job now */
         }
 
     }
