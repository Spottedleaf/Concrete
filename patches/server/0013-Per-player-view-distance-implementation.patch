From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 21 Sep 2019 00:44:19 -0700
Subject: [PATCH] Per player view distance implementation

This patch implements CraftPlayer#setViewDistance and
CraftPlayer#getViewDistance

This patch replaces the existing system to handle player tickets
and chunk sending to players.
 Most of the work is pulled by two
PlayerAreaMap's controlling: a radius for sending chunks and a radius
for adding player tickets. Currently the difference between the two
radii is just 1.
Normal vanilla has a difference of two, but this
causes issues where outer chunks in the view distance sometimes
do not send. This is because the outer radius is not guaranteed to
be at ticket level 32, which is required to be sent to players.

The ticket manager in ChunkMapDistance for players is no longer used and
is entirely replaced by the ticket distance map. The ticket tracker also
adds a configurable chunk load rate per player.

This patch moves the order of the distance map update in movePlayer
until after a client is sent a center section packet. This is required
to avoid the client rejecting chunks it receives when teleporting.

diff --git a/src/main/java/ca/spottedleaf/concrete/config/ConcreteConfig.java b/src/main/java/ca/spottedleaf/concrete/config/ConcreteConfig.java
index d2942e46bcf0c8e0cdbf3c71e60bd66d5ddb81ec..8f5d4fd24a2e4c716204a31455506a6e464b2dd6 100644
--- a/src/main/java/ca/spottedleaf/concrete/config/ConcreteConfig.java
+++ b/src/main/java/ca/spottedleaf/concrete/config/ConcreteConfig.java
@@ -100,6 +100,15 @@ public final class ConcreteConfig {
         tickThreads = ConcreteConfig.getInt("server-tick-threads", 1); // will be 4 in the future
     }
 
+    public static int maxChunkLoadsPerPlayer;
+
+    private static void maxChunkLoadsPerPlayer() {
+        maxChunkLoadsPerPlayer = ConcreteConfig.getInt("max-pending-chunk-tickets-per-player", 49);
+        if (maxChunkLoadsPerPlayer <= -1) {
+            maxChunkLoadsPerPlayer = Integer.MAX_VALUE;
+        }
+    }
+
     public static final class WorldConnfig {
 
         public final String worldName;
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fd3776d6f013f79c692bc217315683e15cd616a6..f9cd05765e16afe24012996b54531965d05a0541 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -47,6 +47,9 @@ public class WorldTimingsHandler {
     public final Timing playerViewDistanceMapUpdate;
     public final Timing playerViewDistanceMapAdd;
     public final Timing playerViewDistanceMapRemove;
+
+
+    public final Timing playerTicketTrackerTick;
     /* Concrete end */
 
     public final Timing syncChunkLoadTimer;
@@ -88,6 +91,9 @@ public class WorldTimingsHandler {
         playerViewDistanceMapUpdate = Timings.ofSafe("Player View Distance Map - Update");
         playerViewDistanceMapAdd = Timings.ofSafe("Player View Distance Map - Add");
         playerViewDistanceMapRemove = Timings.ofSafe("Player View Distance Map - Remove");
+
+
+        playerTicketTrackerTick = Timings.ofSafe("Player ticket tracker tick");
         /* Concrete end */
 
         mobSpawn = Timings.ofSafe(name + "mobSpawn");
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index ca0efec1c42e1997e255dd06055b704028664e9a..c1985e3d3b7c0d56c1d738a0df6a7fc74557baee 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.concrete.util.Util; /* Concrete */
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
@@ -27,12 +28,12 @@ import org.apache.logging.log4j.Logger;
 public abstract class ChunkMapDistance {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2;
+    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2; public static int getPlayerTicketLevel() { return ChunkMapDistance.b; } /* Concrete - OBFHELPER */
     private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
     public final Long2ObjectOpenHashMap<ArraySetSorted<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final ChunkMapDistance.a e = new ChunkMapDistance.a();
     private final ChunkMapDistance.b f = new ChunkMapDistance.b(8);
-    private final ChunkMapDistance.c g = new ChunkMapDistance.c(33);
+    //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); /* Concrete - no longer used */
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.LinkedList<>(); // PAIL pendingChunkUpdates // Paper - use a queue
     private final ChunkTaskQueueSorter i;
     private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> j;
@@ -41,6 +42,11 @@ public abstract class ChunkMapDistance {
     private final Executor m;
     private long currentTick;
 
+    /* Concrete start */
+    protected PlayerChunkMap chunkMap;
+    protected final ChunkMapDistance.TicketTracker playerTicketHandler = new TicketTracker();
+    /* Concrete end */
+
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
         Mailbox<Runnable> mailbox = Mailbox.a("player ticket throttler", executor1::execute);
@@ -87,7 +93,7 @@ public abstract class ChunkMapDistance {
 
     public boolean a(PlayerChunkMap playerchunkmap) {
         this.f.a();
-        this.g.a();
+        //this.g.a(); /* Concrete - no longer used */
         int i = Integer.MAX_VALUE - this.e.a(Integer.MAX_VALUE);
         boolean flag = i != 0;
 
@@ -225,7 +231,7 @@ public abstract class ChunkMapDistance {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
         this.f.b(i, 0, true);
-        this.g.b(i, 0, true);
+        //this.g.b(i, 0, true); /* Concrete - no longer used */
     }
 
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
@@ -237,7 +243,7 @@ public abstract class ChunkMapDistance {
         if (objectset.isEmpty()) {
             this.c.remove(i);
             this.f.b(i, Integer.MAX_VALUE, false);
-            this.g.b(i, Integer.MAX_VALUE, false);
+            //this.g.b(i, Integer.MAX_VALUE, false); /* Concrete - no longer used */
         }
 
     }
@@ -255,9 +261,16 @@ public abstract class ChunkMapDistance {
         return s;
     }
 
+    protected void setViewDistance(int viewDistance) { this.a(viewDistance); } /* Concrete - OBFHELPER */
     protected void a(int i) {
-        this.g.a(i);
+        //this.g.a(i); /* Concrete - no longer used */
+    }
+    /* Concrete start - per player view distance */
+    protected void setGlobalViewDistance(int viewDistance, PlayerChunkMap chunkMap) {
+        this.chunkMap = chunkMap;
+        this.setViewDistance(viewDistance);
     }
+    /* Concrete end */
 
     public int b() {
         this.f.a();
@@ -334,6 +347,199 @@ public abstract class ChunkMapDistance {
         }
     }
 
+    /* Concrete start - Per player view distance */
+    class TicketTracker {
+
+        static final int LOADED_PLAYER_REFERENCE = -2;
+
+        private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap chunkReferenceMap = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap(8192, 0.25f);
+        {
+            this.chunkReferenceMap.defaultReturnValue(-1);
+        }
+        private final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap lastLoadedRadiusByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        {
+            this.lastLoadedRadiusByPlayer.defaultReturnValue(-1);
+        }
+
+        private final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap pendingChunkLoadsByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        private final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkPositionByPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+        {
+            this.lastChunkPositionByPlayer.defaultReturnValue(Long.MIN_VALUE);
+        }
+
+        private final java.util.List<EntityPlayer> players = new java.util.ArrayList<>(256);
+
+        private boolean tryQueueChunk(int chunkX, int chunkZ, EntityPlayer player) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            if (this.chunkReferenceMap.putIfAbsent(coordinate, player.getId()) == -1) {
+                ChunkMapDistance.this.addTicket(coordinate, new Ticket<>(TicketType.PLAYER, ChunkMapDistance.getPlayerTicketLevel(), new ChunkCoordIntPair(chunkX, chunkZ)));
+                return true;
+            }
+            return false;
+        }
+
+        public void tick() {
+            PlayerChunkMap chunkMap = ChunkMapDistance.this.chunkMap;
+            for (EntityPlayer player : this.players) {
+                int playerId = player.getId();
+                int lastLoadedRadius = this.lastLoadedRadiusByPlayer.get(playerId);
+                int pendingChunkLoads = this.pendingChunkLoadsByPlayer.get(playerId);
+                long lastChunkPos = this.lastChunkPositionByPlayer.get(playerId);
+                long currentChunkPos = chunkMap.playerViewDistanceTicketMap.getLastCoordinate(player);
+
+                if (currentChunkPos == Long.MIN_VALUE) {
+                    // not tracking for whatever reason...
+                    continue;
+                }
+
+                int newX = Util.getCoordinateX(currentChunkPos);
+                int newZ = Util.getCoordinateZ(currentChunkPos);
+
+                // handle movement
+                if (currentChunkPos != lastChunkPos) {
+                    this.lastChunkPositionByPlayer.put(playerId, currentChunkPos);
+                    if (lastChunkPos != Long.MIN_VALUE) {
+                        int oldX = Util.getCoordinateX(lastChunkPos);
+                        int oldZ = Util.getCoordinateZ(lastChunkPos);
+
+                        int radiusDiff = Math.max(Math.abs(newX - oldX), Math.abs(newZ - oldZ));
+                        lastLoadedRadius = Math.max(-1, lastLoadedRadius - radiusDiff);
+                        this.lastLoadedRadiusByPlayer.put(playerId, lastLoadedRadius);
+                    }
+                }
+
+                int maxChunkLoads = ca.spottedleaf.concrete.config.ConcreteConfig.maxChunkLoadsPerPlayer; // per-player limits instead of global?
+
+                int radius = lastLoadedRadius + 1;
+                int viewDistance = chunkMap.playerViewDistanceTicketMap.getLastViewDistance(player);
+
+                if (radius > viewDistance) {
+                    // distance map will unload our chunks
+                    this.lastLoadedRadiusByPlayer.put(playerId, viewDistance);
+                    continue;
+                }
+
+                if (pendingChunkLoads >= maxChunkLoads) {
+                    continue;
+                }
+
+                radius_loop:
+                for (; radius <= viewDistance; ++radius) {
+                    for (int offset = 0; offset <= radius; ++offset) {
+                        // try to load the chunks closest to the player by distance
+                        // so instead of going left->right on the x axis, we start at the center of the view distance square
+                        // and go left and right at the same time
+
+                        // try top 2 chunks
+                        // top left
+                        if (this.tryQueueChunk(newX - offset, newZ + radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // top right
+                        if (this.tryQueueChunk(newX + offset, newZ + radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // try bottom 2 chunks
+
+                        // bottom left
+                        if (this.tryQueueChunk(newX - offset, newZ - radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // bottom right
+                        if (this.tryQueueChunk(newX + offset, newZ - radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // try left 2 chunks
+
+                        // left down
+                        if (this.tryQueueChunk(newX - radius, newZ - offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // left up
+                        if (this.tryQueueChunk(newX - radius, newZ + offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // try right 2 chunks
+
+                        // right down
+                        if (this.tryQueueChunk(newX + radius, newZ - offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // right up
+                        if (this.tryQueueChunk(newX + radius, newZ + offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+                    }
+                }
+
+                int newLoadedRadius = radius - 1;
+                if (newLoadedRadius != lastLoadedRadius) {
+                    this.lastLoadedRadiusByPlayer.put(playerId, newLoadedRadius);
+                }
+                this.pendingChunkLoadsByPlayer.put(playerId, pendingChunkLoads);
+            }
+        }
+
+        public void addPlayer(EntityPlayer player) {
+            this.players.add(player);
+        }
+
+        public void removePlayer(EntityPlayer player) {
+            this.players.remove(player);
+            this.lastLoadedRadiusByPlayer.remove(player.getId());
+            this.pendingChunkLoadsByPlayer.remove(player.getId());
+            this.lastChunkPositionByPlayer.remove(player.getId());
+        }
+
+        public void onChunkSetEntityTicking(int chunkX, int chunkZ) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.replace(coordinate, LOADED_PLAYER_REFERENCE);
+            if (playerReference != -1) {
+                this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                    return valueInMap - 1;
+                });
+            }
+        }
+
+        // this is invoked if and only if there are no other players in range of the chunk.
+        public void playerMoveOutOfRange(int chunkX, int chunkZ) {
+            long coordinate = Util.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.remove(coordinate);
+            if (playerReference != -1) {
+                if (playerReference != LOADED_PLAYER_REFERENCE) {
+                    this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                        return valueInMap - 1;
+                    });
+                }
+                ChunkMapDistance.this.removeTicket(coordinate, new Ticket<>(TicketType.PLAYER, ChunkMapDistance.getPlayerTicketLevel(), new ChunkCoordIntPair(chunkX, chunkZ)));
+            }
+        }
+    }
+    /* Concrete end - per player view distance */
+
     class c extends ChunkMapDistance.b {
 
         private int e = 0;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index b09d33cb228ced761f2a44d4ca05c2a72b44bcb6..e63ef5ebd721215a1b8fea43a651aaf58cf8ca65 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -595,6 +595,11 @@ public class ChunkProviderServer extends IChunkProvider {
         this.chunkMapDistance.purgeTickets();
         this.tickDistanceManager();
         this.world.timings.doChunkMap.stopTiming(); // Spigot
+        /* Concrete start */
+        this.world.timings.playerTicketTrackerTick.startTiming();
+        this.playerChunkMap.getChunkMapDistanceManager().playerTicketHandler.tick();
+        this.world.timings.playerTicketTrackerTick.stopTiming();
+        /* Concrete end */
         this.world.getMethodProfiler().exitEnter("chunks");
         this.world.timings.chunks.startTiming(); // Paper - timings
         this.tickChunks();
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index 9acdd6e5665e506ab55f0cb0525212a0d8db3be9..f89281b1c2ad1edc5701f611ef0a745b28dbb087 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -579,9 +579,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API /* Concrete - per player view distance */
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) << 4; /* Concrete - per player view distance */
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 33150621f6b545e5a57156e753c2903a65edacf6..28f8808ae4997017374a2f3a27ff38e0bc4ecf99 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -102,6 +102,12 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     /* Concrete start */
     public final ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> cachedSingleHashSet;
+
+    public int viewDistance = -1;
+    public int getEffectiveViewDistance(PlayerChunkMap chunkMap) {
+        return this.viewDistance == -1 ? chunkMap.viewDistance : this.viewDistance;
+    }
+    public boolean needsChunkCenterUpdate;
     /* Concrete end */
 
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8977c3516b2ee9b970b6274a5c71982b019ac2a6..38de74d95c5cac1a6ae11f226726a7a11c4781e9 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API /* Concrete - per player view distance */
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(player.getWorldServer().getChunkProvider().playerChunkMap) << 4; /* Concrete - per player view distance */
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index fb7e8626f73d47fc4cd439488dbf9fe56f230c32..9a1c2110a651c77fb265bfbb2e72c9a744d20c23 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -278,6 +278,50 @@ public class PlayerChunk {
     }
 
     private void a(Packet<?> packet, boolean flag) {
+        /* Concrete start - per player view distance */
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        if (this.players instanceof PlayerChunkMap) {
+            PlayerChunkMap chunkMap = ((PlayerChunkMap)this.players);
+            ca.spottedleaf.concrete.util.map.PlayerAreaMap viewDistanceMap = ((PlayerChunkMap)this.players).playerViewDistanceBroadcastMap;
+            ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = viewDistanceMap.getObjectsInRange(this.location);
+            if (players == null) {
+                return;
+            }
+
+            if (flag) { // flag -> border only
+                Object[] backingSet = players.getBackingSet();
+                for (int i = 0, len = backingSet.length; i < len; ++i) {
+                    Object temp = backingSet[i];
+                    if (!(temp instanceof EntityPlayer)) {
+                        continue;
+                    }
+                    EntityPlayer player = (EntityPlayer)temp;
+                    int viewDistance = viewDistanceMap.getLastViewDistance(player);
+                    long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                    int distX = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateX(lastPosition) - this.location.x);
+                    int distZ = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateZ(lastPosition) - this.location.z);
+
+                    if (Math.max(distX, distZ) == viewDistance) {
+                        player.playerConnection.sendPacket(packet);
+                    }
+                }
+            } else {
+                Object[] backingSet = players.getBackingSet();
+                for (int i = 0, len = backingSet.length; i < len; ++i) {
+                    Object temp = backingSet[i];
+                    if (!(temp instanceof EntityPlayer)) {
+                        continue;
+                    }
+                    EntityPlayer player = (EntityPlayer)temp;
+                    player.playerConnection.sendPacket(packet);
+                }
+            }
+
+            return;
+        }
+        /* Concrete end - per player view distance */
         this.players.a(this.location, flag).forEach((entityplayer) -> {
             entityplayer.playerConnection.sendPacket(packet);
         });
@@ -443,6 +487,7 @@ public class PlayerChunk {
                     } else {
                         chunkProvder.entityTickingChunks.add(chunk);
                     }
+                    PlayerChunk.this.chunkMap.getChunkMapDistanceManager().playerTicketHandler.onChunkSetEntityTicking(this.location.x, this.location.z); /* Concrete - per player view distance implementation */
                 }
             });
             /* Concrete end - cache chunk ticking stage */
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index b6608203690ca998afe2e249a02d90307276c4b0..044784f692583ec247ffe487441a2721a7aa2198 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -79,7 +79,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final PlayerMap playerMap;
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> z;
-    int viewDistance; // Paper - private -> package private
+    int viewDistance; public final int getViewDistance() { return this.viewDistance; } /* Concrete - OBFHELPER */ // Paper - private -> package private
     //public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper /* Concrete - replaced by view distance map */
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
@@ -110,15 +110,29 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     /* Concrete start */
     public final ca.spottedleaf.concrete.util.map.PlayerAreaMap playerViewDistanceMap;
 
+
+    // we use this map to broadcast chunks to clients
+    // they do not render chunks without having at least neighbours in a 1 chunk radius loaded
+    public final ca.spottedleaf.concrete.util.map.PlayerAreaMap playerViewDistanceBroadcastMap;
+    public final ca.spottedleaf.concrete.util.map.PlayerAreaMap playerViewDistanceTicketMap;
+
+    private static int getTicketLevelDistance(final int distance) {
+        return distance;
+    }
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         try (co.aikar.timings.Timing ignored = this.world.timings.playerViewDistanceMapAdd.startTiming()) {
             this.updateMaps(player);
+            this.getChunkMapDistanceManager().playerTicketHandler.addPlayer(player);
         }
     }
 
     void removePlayerFromDistanceMaps(EntityPlayer player) {
         try (co.aikar.timings.Timing ignored = this.world.timings.playerViewDistanceMapRemove.startTiming()) {
+            this.playerViewDistanceBroadcastMap.remove(player);
+            this.playerViewDistanceTicketMap.remove(player);
             this.playerViewDistanceMap.remove(player);
+            this.getChunkMapDistanceManager().playerTicketHandler.removePlayer(player);
         }
     }
 
@@ -128,11 +142,38 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
     }
 
+    public void updateViewDistance(EntityPlayer player, int viewDistance) {
+        player.viewDistance = viewDistance;
+
+        int chunkX = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locX());
+        int chunkZ = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locZ());
+
+        int effectiveViewDistance = viewDistance == -1 ? this.viewDistance : viewDistance;
+
+        player.playerConnection.sendPacket(new PacketPlayOutViewDistance(effectiveViewDistance));
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTicketMap.update(player, chunkX, chunkZ, getTicketLevelDistance(effectiveViewDistance));
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveViewDistance + 1); // clients need chunk neighbours
+        player.needsChunkCenterUpdate = false;
+    }
+
     private void updateMaps(EntityPlayer player) {
         int chunkX = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locX());
         int chunkZ = ca.spottedleaf.concrete.util.Util.getChunkCoordinate(player.locZ());
 
-        this.playerViewDistanceMap.update(player, chunkX, chunkZ, this.viewDistance);
+        int effectiveViewDistance = player.getEffectiveViewDistance(this);
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTicketMap.update(player, chunkX, chunkZ, getTicketLevelDistance(effectiveViewDistance));
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance); /* Concrete - per player view distance */
+        player.needsChunkCenterUpdate = true;
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveViewDistance + 1); // clients need chunk neighbours
+        player.needsChunkCenterUpdate = false;
     }
     /* Concrete end */
 
@@ -168,7 +209,35 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.m = new VillagePlace(new File(this.w, "poi"), datafixer, this.world); // Paper
         this.setViewDistance(i);
         //this.playerMobDistanceMap = this.world.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper /* Concrete - use the distance map */
-        this.playerViewDistanceMap = new ca.spottedleaf.concrete.util.map.PlayerAreaMap(); /* Concrete */
+        /* Concrete start - distance maps */
+        ca.spottedleaf.concrete.util.map.PooledLinkedHashSets<EntityPlayer> sets = new ca.spottedleaf.concrete.util.map.PooledLinkedHashSets<>();
+        this.playerViewDistanceTicketMap = new ca.spottedleaf.concrete.util.map.PlayerAreaMap(sets,
+                null,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (newState != null) {
+                        return;
+                    }
+                    PlayerChunkMap.this.chunkDistanceManager.playerTicketHandler.playerMoveOutOfRange(rangeX, rangeZ);
+                });
+        this.playerViewDistanceMap = new ca.spottedleaf.concrete.util.map.PlayerAreaMap(sets);
+        final Packet[] tempPacket = new Packet[2];
+        this.playerViewDistanceBroadcastMap = new ca.spottedleaf.concrete.util.map.PlayerAreaMap(sets,
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    if (player.needsChunkCenterUpdate) {
+                        player.needsChunkCenterUpdate = false;
+                        player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));
+                    }
+                    PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, tempPacket, false, true); // unloaded, loaded
+                    java.util.Arrays.fill(tempPacket, null);
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, tempPacket, true, false); // unloaded, loaded
+                    java.util.Arrays.fill(tempPacket, null);
+                });
+        /* Concrete end - distance maps */
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -897,9 +966,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 this.u.getAndIncrement();
                 Packet<?>[] apacket = new Packet[2];
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.a(entityplayer, apacket, chunk);
-                });
+                /* Concrete start - per player view distance */
+                // there can be potential desync with player's last mapped section and the view distance map, so use the
+                // view distance map here.
+                ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = PlayerChunkMap.this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+                if (players != null) {
+                    Object[] backingSet = players.getBackingSet();
+                    for (int i = 0, len = backingSet.length; i < len; ++i) {
+                        Object temp = backingSet[i];
+                        if (!(temp instanceof EntityPlayer)) {
+                            continue;
+                        }
+                        EntityPlayer player = (EntityPlayer)temp;
+                        this.a(player, apacket, chunk);
+                    }
+                }
+                /* Concrete end - per player view distance */
                 return Either.left(chunk);
             });
         }, (runnable) -> {
@@ -1002,28 +1084,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void setViewDistance(int i) {
-        int j = MathHelper.clamp(i + 1, 3, 33);
+        int j = MathHelper.clamp(i + 1, 3, 33) - 1; /* Concrete - we correctly handle view distance, no need to add 1 */
 
         if (j != this.viewDistance) {
             int k = this.viewDistance;
 
             this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            Iterator objectiterator = this.chunkMap.getUpdatingValues().iterator(); /* Concrete - replace chunk map */
-
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
-
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+            this.chunkDistanceManager.setGlobalViewDistance(this.viewDistance, this); /* Concrete - per player view distance */
+            /* Concrete start - view distance map handles this */
+            if (this.world != null && this.world.players != null) { // ... called inside constructor, where these may not be initialized
+                for (EntityPlayer player : this.world.players) {
+                    if (player.viewDistance == -1) {
+                        this.updateViewDistance(player, -1);
+                    }
+                }
             }
+            /* Concrete end - view distance map handles this */
         }
 
     }
@@ -1286,6 +1362,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         });
     }
 
+    private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } /* Concrete - OBFHELPER */
     private boolean b(EntityPlayer entityplayer) {
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
@@ -1311,15 +1388,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        Packet[] cachedPackets = new Packet[2]; /* Concrete */
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                /* Concrete start - remove excess object creation (ChunkCoordIntPair and Packet[]) */
-                this.sendChunk(entityplayer, k, l, cachedPackets, !flag, flag);
-                java.util.Arrays.fill(cachedPackets, null);
-                /* Concrete end */
-            }
+        /* Concrete start - view distance map handles this */
+        if (flag) {
+            this.updateMaps(entityplayer);
         }
+        /* Concrete end - view distance map handles this */
 
     }
 
@@ -1327,12 +1400,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         SectionPosition sectionposition = SectionPosition.a((Entity) entityplayer);
 
         entityplayer.a(sectionposition);
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutViewCentre(sectionposition.a(), sectionposition.c()));
+        //entityplayer.playerConnection.sendPacket(new PacketPlayOutViewCentre(sectionposition.a(), sectionposition.c())); /* Concrete - distance map handles this now */
         return sectionposition;
     }
 
     public void movePlayer(EntityPlayer entityplayer) {
-        this.updateDistanceMaps(entityplayer); /* Concrete - distance maps */
         ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -1383,66 +1455,53 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        this.updateDistanceMaps(entityplayer); /* Concrete - this is replaced by the calllbacks in the view distance map */
 
-            Packet[] cachedPackets = new Packet[2]; /* Concrete */
+    }
 
-            for (int k2 = k1; k2 <= i2; ++k2) {
-                for (int l2 = l1; l2 <= j2; ++l2) {
-                    /* Concrete start - remove ChunkCoordIntPair allocation */
-                    boolean flag3 = getSquareRadiusDistance(k2, l2, i1, j1) <= this.viewDistance;
-                    boolean flag4 = getSquareRadiusDistance(k2, l2, i, j) <= this.viewDistance;
+    @Override
+    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        /* Concrete start - per player view distance */
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        ca.spottedleaf.concrete.util.map.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<EntityPlayer> players = new ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (flag) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
+
+                int distX = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateX(lastPosition) - chunkcoordintpair.x);
+                int distZ = Math.abs(ca.spottedleaf.concrete.util.Util.getCoordinateZ(lastPosition) - chunkcoordintpair.z);
 
-                    this.sendChunk(entityplayer, k2, l2, cachedPackets, flag3, flag4);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    /* Concrete end */
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
                 }
             }
         } else {
-            //ChunkCoordIntPair chunkcoordintpair1; /* Concrete - we don't set, so compile fail on further uses */
-            boolean flag5;
-            boolean flag6;
-
-            Packet[] cachedPackets = new Packet[2]; /* Concrete */
-
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    /* Concrete - remove ChunkCoordIntPair allocation */
-                    flag5 = true;
-                    flag6 = false;
-                    /* Concrete start - remove ChunkCoordIntPair allocation */
-                    this.sendChunk(entityplayer, k1, l1, cachedPackets, true, false);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    /* Concrete end */
-                }
-            }
-
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    /* Concrete - remove ChunkCoordIntPair allocation */
-                    flag5 = false;
-                    flag6 = true;
-                    /* Concrete start - remove ChunkCoordIntPair allocation */
-                    this.sendChunk(entityplayer, k1, l1, cachedPackets, false, true);
-                    java.util.Arrays.fill(cachedPackets, null);
-                    /* Concrete end */
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
                 }
+                EntityPlayer player = (EntityPlayer)temp;
+                players.add(player);
             }
         }
-
-    }
-
-    @Override
-    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
-        return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
-            int i = b(chunkcoordintpair, entityplayer, true);
-
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
-        });
+        return players.stream();
+        /* Concrete end - per player view distance */
     }
 
     protected void addEntity(Entity entity) {
@@ -1698,7 +1757,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 double vec3d_dy = entityplayer.locY() - this.tracker.locY();
                 double vec3d_dz = entityplayer.locZ() - this.tracker.locZ();
                 /* Concrete end - remove allocation of Vec3d here */
-                int i = Math.min(this.b(), (PlayerChunkMap.this.viewDistance - 1) * 16);
+                int i = Math.min(this.b(), (entityplayer.getEffectiveViewDistance(PlayerChunkMap.this)) * 16);  /* Concrete - per player view distance */
                 boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.tracker.a(entityplayer); /* Concrete start - remove allocation of Vec3d here */
                 if (flag) {
                     boolean flag1 = this.tracker.attachedToPlayer;
@@ -1708,7 +1767,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
+                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.playerViewDistanceBroadcastMap.getLastViewDistance(entityplayer); /* Concrete - per player view distance */
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 7b79ee4fe5893d0c8c5825776c3c09ca8553abc8..b93545b0da26a97312377403e5733c2ea6d7552c 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -156,7 +156,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, flag1, !flag));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), entityplayer.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap), flag1, !flag)); /* Concrete - per player view distance */
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -700,7 +700,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(),  WorldData.c(worldserver.getWorldData().getSeed()), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(entityplayer1.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap))); // Spigot /* Concrete - per player view distance */
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX(), entityplayer1.locY(), entityplayer1.locZ(), entityplayer1.yaw, entityplayer1.pitch));
@@ -1178,7 +1178,7 @@ public abstract class PlayerList {
 
     public void a(int i) {
         this.viewDistance = i;
-        this.sendAll(new PacketPlayOutViewDistance(i));
+        //this.sendAll(new PacketPlayOutViewDistance(i)); /* Concrete - move into setViewDistance */
         Iterator iterator = this.server.getWorlds().iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 3afcfeae11a4723ee258e7f452073f89b82e3c35..ea3566b4c1a06d23d978db48f53e1aaa4a704c19 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.entity;
 
+import ca.spottedleaf.concrete.util.TickThread; /* Concrete */
 import com.destroystokyo.paper.Title;
 import com.destroystokyo.paper.profile.CraftPlayerProfile;
 import com.destroystokyo.paper.profile.PlayerProfile;
@@ -1973,12 +1974,20 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().viewDistance == -1 ? ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.getViewDistance() : getHandle().viewDistance; /* Concrete - per player view distance */
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        TickThread.ensureTickThread("Cannot update view distance safely off of the main thread");
+        /* Concrete start - per player view distance */
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        if (viewDistance != getHandle().viewDistance) {
+            ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.updateViewDistance(getHandle(), viewDistance);
+        }
+        /* Concrete end - per player view distance */
     }
     // Paper end
 
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 92601c581cffac471872226abeb93ef9aa24f079..0e36fca47dc32b9fb747a7f42a2164fb3570eaa2 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -33,6 +33,7 @@ import net.minecraft.server.MathHelper;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.World;
 import co.aikar.timings.MinecraftTimings;
+import net.minecraft.server.WorldServer; /* Concrete */
 
 public class ActivationRange
 {
@@ -119,14 +120,15 @@ public class ActivationRange
         final int animalActivationRange = world.spigotConfig.animalActivationRange;
         final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
 
-        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
-        maxRange = Math.max( maxRange, raiderActivationRange );
-        maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        /* Concrete start - per player view distance */
+        int maxRangeTemp = Math.max( monsterActivationRange, animalActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, raiderActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, miscActivationRange );
 
         for ( EntityHuman player : world.getPlayers() )
         {
-
+            final int maxRange = Math.min( ( ( player instanceof net.minecraft.server.EntityPlayer ? ((net.minecraft.server.EntityPlayer)player).getEffectiveViewDistance(((WorldServer)world).getChunkProvider().playerChunkMap) : world.spigotConfig.viewDistance ) << 4 ) - 8, maxRangeTemp );
+            /* Concrete end - per player view distance */
             player.activatedTick = MinecraftServer.currentTick;
             maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
